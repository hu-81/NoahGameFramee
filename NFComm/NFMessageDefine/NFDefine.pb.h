// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: NFDefine.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_NFDefine_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_NFDefine_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3010000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3010000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_NFDefine_2eproto LIBPROTOC_EXPORT
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct LIBPROTOC_EXPORT TableStruct_NFDefine_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[1]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern LIBPROTOC_EXPORT const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_NFDefine_2eproto;
PROTOBUF_NAMESPACE_OPEN
PROTOBUF_NAMESPACE_CLOSE
namespace NFMsg {

enum EGameEventCode : int {
  EGEC_SUCCESS = 0,
  EGEC_UNKOWN_ERROR = 1,
  EGEC_ACCOUNT_EXIST = 2,
  EGEC_ACCOUNTPWD_INVALID = 3,
  EGEC_ACCOUNT_USING = 4,
  EGEC_ACCOUNT_LOCKED = 5,
  EGEC_ACCOUNT_SUCCESS = 6,
  EGEC_VERIFY_KEY_SUCCESS = 7,
  EGEC_VERIFY_KEY_FAIL = 8,
  EGEC_SELECTSERVER_SUCCESS = 9,
  EGEC_SELECTSERVER_FAIL = 10,
  EGEC_CHARACTER_EXIST = 110,
  EGEC_SVRZONEID_INVALID = 111,
  EGEC_CHARACTER_NUMOUT = 112,
  EGEC_CHARACTER_INVALID = 113,
  EGEC_CHARACTER_NOTEXIST = 114,
  EGEC_CHARACTER_USING = 115,
  EGEC_CHARACTER_LOCKED = 116,
  EGEC_ZONE_OVERLOAD = 117,
  EGEC_NOT_ONLINE = 118,
  EGEC_ALREAY_IN_TEAM = 119,
  EGEC_INVALID_TEAM_INVITE = 120,
  EGEC_TEAM_FULL = 121,
  EGEC_MAIL_UPDATE_ERROR = 122,
  EGEC_MAIL_TONAME_INVALID = 123,
  EGEC_MAIL_DELETE_ERROR = 124,
  EGEC_MAIL_TOWNAME_EQUAL = 125,
  EGEC_LACK_MONEY = 126,
  EGEC_FULL_PACKAGE = 127,
  EGEC_INVALID_ITEM = 128,
  EGEC_INVALID_CONSIGNMENT = 129,
  EGEC_NOT_ENOUGH_VIP = 130,
  EGEC_NEED_LEVEL = 131,
  EGEC_MAX_FRIEND_LIST = 132,
  EGEC_MAX_ENEMY_LIST = 133,
  EGEC_MAX_GANGS_LSIT = 134,
  EGEC_LIMITS_TO_RIGHTS = 135,
  EGEC_INVALID_GANGS_NAME = 136,
  EGEC_REPEAT_ENTER_GANGS = 137,
  EGEC_INVALID_GANGSMEMBER = 138,
  EGEC_MASTER_LEAVE_GANGS = 139,
  EGEC_GANGS_TITLE_OUTOF = 140,
  EGEC_ENTER_GATEWAY_FAILD = 141,
  EGEC_NO_SERVER4ZONE = 142,
  EGEC_INVALID_SKILL = 143,
  EGEC_CREATE_CLAN_SUCCESS = 200,
  EGEC_JOIN_CLAN_SUCCESS = 201,
  EGEC_LEAVE_CLAN_SUCCESS = 202,
  EGameEventCode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  EGameEventCode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
LIBPROTOC_EXPORT bool EGameEventCode_IsValid(int value);
constexpr EGameEventCode EGameEventCode_MIN = EGEC_SUCCESS;
constexpr EGameEventCode EGameEventCode_MAX = EGEC_LEAVE_CLAN_SUCCESS;
constexpr int EGameEventCode_ARRAYSIZE = EGameEventCode_MAX + 1;

LIBPROTOC_EXPORT const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EGameEventCode_descriptor();
template<typename T>
inline const std::string& EGameEventCode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EGameEventCode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EGameEventCode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EGameEventCode_descriptor(), enum_t_value);
}
inline bool EGameEventCode_Parse(
    const std::string& name, EGameEventCode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EGameEventCode>(
    EGameEventCode_descriptor(), name, value);
}
enum ESynMsgID : int {
  ESMI_UNKNOW = 0,
  ESynMsgID_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ESynMsgID_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
LIBPROTOC_EXPORT bool ESynMsgID_IsValid(int value);
constexpr ESynMsgID ESynMsgID_MIN = ESMI_UNKNOW;
constexpr ESynMsgID ESynMsgID_MAX = ESMI_UNKNOW;
constexpr int ESynMsgID_ARRAYSIZE = ESynMsgID_MAX + 1;

LIBPROTOC_EXPORT const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ESynMsgID_descriptor();
template<typename T>
inline const std::string& ESynMsgID_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ESynMsgID>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ESynMsgID_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ESynMsgID_descriptor(), enum_t_value);
}
inline bool ESynMsgID_Parse(
    const std::string& name, ESynMsgID* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ESynMsgID>(
    ESynMsgID_descriptor(), name, value);
}
enum EGameMsgID : int {
  EGMI_UNKNOW = 0,
  EGMI_EVENT_RESULT = 1,
  EGMI_EVENT_TRANSPOND = 2,
  EGMI_CLOSE_SOCKET = 3,
  EGMI_WTM_WORLD_REGISTERED = 10,
  EGMI_WTM_WORLD_UNREGISTERED = 11,
  EGMI_WTM_WORLD_REFRESH = 12,
  EGMI_LTM_LOGIN_REGISTERED = 20,
  EGMI_LTM_LOGIN_UNREGISTERED = 21,
  EGMI_LTM_LOGIN_REFRESH = 22,
  EGMI_PTWG_PROXY_REGISTERED = 30,
  EGMI_PTWG_PROXY_UNREGISTERED = 31,
  EGMI_PTWG_PROXY_REFRESH = 32,
  EGMI_GTW_GAME_REGISTERED = 40,
  EGMI_GTW_GAME_UNREGISTERED = 41,
  EGMI_GTW_GAME_REFRESH = 42,
  EGMI_DTW_DB_REGISTERED = 60,
  EGMI_DTW_DB_UNREGISTERED = 61,
  EGMI_DTW_DB_REFRESH = 62,
  EGMI_STS_NET_INFO = 70,
  EGEC_REQ_LAG_TEST = 80,
  EGEC_ACK_GATE_LAG_TEST = 81,
  EGEC_ACK_GAME_LAG_TEST = 82,
  EGMI_STS_SERVER_REPORT = 90,
  EGMI_STS_HEART_BEAT = 100,
  EGMI_REQ_LOGIN = 101,
  EGMI_ACK_LOGIN = 102,
  EGMI_REQ_LOGOUT = 103,
  EGMI_REQ_WORLD_LIST = 110,
  EGMI_ACK_WORLD_LIST = 111,
  EGMI_REQ_CONNECT_WORLD = 112,
  EGMI_ACK_CONNECT_WORLD = 113,
  EGMI_REQ_KICK_CLIENT_INWORLD = 114,
  EGMI_REQ_CONNECT_KEY = 120,
  EGMI_ACK_CONNECT_KEY = 122,
  EGMI_REQ_SELECT_SERVER = 130,
  EGMI_ACK_SELECT_SERVER = 131,
  EGMI_REQ_ROLE_LIST = 132,
  EGMI_ACK_ROLE_LIST = 133,
  EGMI_REQ_CREATE_ROLE = 134,
  EGMI_REQ_DELETE_ROLE = 135,
  EGMI_REQ_RECOVER_ROLE = 136,
  EGMI_REQ_LOAD_ROLE_DATA = 140,
  EGMI_ACK_LOAD_ROLE_DATA = 141,
  EGMI_REQ_SAVE_ROLE_DATA = 142,
  EGMI_ACK_SAVE_ROLE_DATA = 143,
  EGMI_REQ_ENTER_GAME = 150,
  EGMI_ACK_ENTER_GAME = 151,
  EGMI_REQ_LEAVE_GAME = 152,
  EGMI_ACK_LEAVE_GAME = 153,
  EGMI_REQ_SWAP_GAME = 154,
  EGMI_REQ_SWAP_SCENE = 155,
  EGMI_ACK_SWAP_SCENE = 156,
  EGMI_REQ_SWAP_HOME_SCENE = 157,
  EGMI_ACK_SWAP_HOME_SCENE = 158,
  EGMI_REQ_ENTER_GAME_FINISH = 159,
  EGMI_ACK_ENTER_GAME_FINISH = 160,
  EGMI_ACK_OBJECT_ENTRY = 200,
  EGMI_ACK_OBJECT_LEAVE = 201,
  EGMI_ACK_OBJECT_PROPERTY_ENTRY = 202,
  EGMI_ACK_OBJECT_RECORD_ENTRY = 203,
  EGMI_ACK_PROPERTY_INT = 210,
  EGMI_ACK_PROPERTY_FLOAT = 211,
  EGMI_ACK_PROPERTY_STRING = 212,
  EGMI_ACK_PROPERTY_OBJECT = 214,
  EGMI_ACK_PROPERTY_VECTOR2 = 215,
  EGMI_ACK_PROPERTY_VECTOR3 = 216,
  EGMI_ACK_PROPERTY_CLEAR = 217,
  EGMI_ACK_ADD_ROW = 220,
  EGMI_ACK_REMOVE_ROW = 221,
  EGMI_ACK_SWAP_ROW = 222,
  EGMI_ACK_RECORD_INT = 223,
  EGMI_ACK_RECORD_FLOAT = 224,
  EGMI_ACK_RECORD_STRING = 226,
  EGMI_ACK_RECORD_OBJECT = 227,
  EGMI_ACK_RECORD_VECTOR2 = 228,
  EGMI_ACK_RECORD_VECTOR3 = 229,
  EGMI_ACK_RECORD_CLEAR = 250,
  EGMI_ACK_RECORD_SORT = 251,
  EGMI_ACK_DATA_FINISHED = 260,
  EGMI_REQ_AI_ONWER = 300,
  EGMI_REQ_SEARCH_OPPNENT = 1220,
  EGMI_ACK_SEARCH_OPPNENT = 1221,
  EGMI_REQ_END_OPPNENT = 1222,
  EGMI_ACK_END_OPPNENT = 1223,
  EGMI_REQ_CANCEL_SEARCH = 1224,
  EGMI_ACK_CANCEL_SEARCH = 1225,
  EGMI_REQ_MOVE = 1230,
  EGMI_ACK_MOVE = 1231,
  EGMI_REQ_MOVE_IMMUNE = 1232,
  EGMI_ACK_MOVE_IMMUNE = 1233,
  EGMI_REQ_STATE_SYNC = 1234,
  EGMI_ACK_STATE_SYNC = 1235,
  EGMI_REQ_POS_SYNC = 1236,
  EGMI_ACK_POS_SYNC = 1237,
  EGMI_REQ_SKILL_OBJECTX = 1240,
  EGMI_ACK_SKILL_OBJECTX = 1241,
  EGMI_REQ_SKILL_POS = 1242,
  EGMI_ACK_SKILL_POS = 1243,
  EGMI_REQ_ITEM_OBJECT = 1244,
  EGMI_ACK_ITEM_OBJECT = 1245,
  EGMI_REQ_ITEM_POS = 1246,
  EGMI_ACK_ITEM_POS = 1247,
  EGMI_REQ_CHAT = 1250,
  EGMI_ACK_CHAT = 1251,
  EGMI_REQ_SALE_ITEM = 1252,
  EGMI_REQ_SPLIT_ITEM = 1253,
  EGMI_REQ_PRODUCE_ITEM = 1254,
  EGMI_REQ_PICK_ITEM = 1255,
  EGMI_REQ_ACCEPT_TASK = 1256,
  EGMI_REQ_COMPELETE_TASK = 1257,
  EGMI_ACK_ONLINE_NOTIFY = 1290,
  EGMI_ACK_OFFLINE_NOTIFY = 1291,
  EGMI_REQ_CREATE_CLAN = 1300,
  EGMI_ACK_CREATE_CLAN = 1301,
  EGMI_REQ_JOIN_CLAN = 1302,
  EGMI_ACK_JOIN_CLAN = 1303,
  EGMI_REQ_LEAVE_CLAN = 1304,
  EGMI_ACK_LEAVE_CLAN = 1305,
  EGMI_REQ_OPR_CLAN = 1306,
  EGMI_ACK_OPR_CLAN = 1307,
  EGMI_REQ_SEARCH_CLAN = 1308,
  EGMI_ACK_SEARCH_CLAN = 1309,
  EGMI_REQ_CANCEL_SEARCH_CLAN = 1310,
  EGEC_REQ_CREATE_CHATGROUP = 1400,
  EGEC_ACK_CREATE_CHATGROUP = 1401,
  EGEC_REQ_JOIN_CHATGROUP = 1402,
  EGEC_ACK_JOIN_CHATGROUP = 1403,
  EGEC_REQ_LEAVE_CHATGROUP = 1404,
  EGEC_ACK_LEAVE_CHATGROUP = 1405,
  EGEC_REQ_SUBSCRIPTION_CHATGROUP = 1406,
  EGEC_REQ_CANCELSUBSCRIPTION_CHATGROUP = 1407,
  EGEC_REQ_INVITE_CHATGROUP = 1408,
  EGEC_ACK_INVITE_CHATGROUP = 1409,
  EGEC_REQ_KICK_CHATGROUP = 1410,
  EGEC_ACK_KICK_CHATGROUP = 1411,
  EGEC_REQ_CHATGROUP_TO_TEAM = 1450,
  EGEC_ACK_CHATGROUP_TO_TEAM = 1451,
  EGEC_REQ_INTENSIFYLEVEL_TO_EQUIP = 1500,
  EGEC_ACK_INTENSIFYLEVEL_TO_EQUIP = 1501,
  EGEC_REQ_HOLE_TO_EQUIP = 1502,
  EGEC_ACK_HOLE_TO_EQUIP = 1503,
  EGEC_REQ_INLAYSTONE_TO_EQUIP = 1504,
  EGEC_ACK_INLAYSTONE_TO_EQUIP = 1505,
  EGEC_REQ_ELEMENTLEVEL_TO_EQUIP = 1506,
  EGEC_ACK_ELEMENTLEVEL_TO_EQUIP = 1507,
  EGEC_WEAR_EQUIP = 1508,
  EGEC_TAKEOFF_EQUIP = 1509,
  EGEC_REQ_SET_FIGHT_HERO = 1520,
  EGEC_REQ_SWITCH_FIGHT_HERO = 1521,
  EGEC_REQ_RELIVE_HERO = 1522,
  EGEC_REQ_SEND_MAIL = 1700,
  EGEC_REQ_DRAW_MAIL = 1701,
  EGEC_REQ_DELETE_MAIL = 1702,
  EGMI_ACK_CLONE_OBJECT_ENTRY = 1800,
  EGMI_ACK_CLONE_OBJECT_LEAVE = 1801,
  EGMI_ACK_CLONE_OBJECT_PROPERTY_ENTRY = 1802,
  EGMI_ACK_CLONE_OBJECT_RECORD_ENTRY = 1803,
  EGMI_ACK_CLONE_PROPERTY_INT = 1810,
  EGMI_ACK_CLONE_PROPERTY_FLOAT = 1811,
  EGMI_ACK_CLONE_PROPERTY_STRING = 1812,
  EGMI_ACK_CLONE_PROPERTY_OBJECT = 1814,
  EGMI_REQSWICHSERVER = 1840,
  EGMI_ACKSWICHSERVER = 1841,
  EGMI_REQ_CREATE_TEAM = 1860,
  EGMI_ACK_CREATE_TEAM = 1861,
  EGMI_REQ_JOIN_TEAM = 1862,
  EGMI_ACK_JOIN_TEAM = 1863,
  EGMI_REQ_LEAVE_TEAM = 1864,
  EGMI_ACK_LEAVE_TEAM = 1865,
  EGMI_REQ_INVITE_TEAM = 1866,
  EGMI_REQ_OPRMEMBER_TEAM = 1867,
  EGMI_ACK_OPRMEMBER_TEAM = 1868,
  EGMI_REQ_TEAM_ENTER_ECTYPE = 1869,
  EGMI_ACK_TEAM_ENTER_ECTYPE = 1870,
  EGMI_REQ_MAP_GRID_INFO = 1900,
  EGMI_ACK_MAP_GRID_INFO = 1901,
  EGMI_REQ_BIG_MAP_INFO = 1902,
  EGMI_ACK_BIG_MAP_INFO = 1903,
  EGMI_REQ_HOLD_MAP_GRID = 1910,
  EGMI_ACK_HOLD_MAP_GRID = 1911,
  EGMI_REQ_LEAVE_MSG_MAP_GRID = 1912,
  EGMI_ACK_LEAVE_MSG_MAP_GRID = 1913,
  EGMI_REQ_GET_MAP_GRID_AWARD = 1914,
  EGMI_ACK_GET_MAP_GRID_AWARD = 1915,
  EGMI_REQ_MAP_GRID_HUNTING = 1916,
  EGMI_ACK_MAP_GRID_HUNTING = 1917,
  EGMI_REQ_MAP_GRID_KING_WAR = 1918,
  EGMI_ACK_MAP_GRID_KING_WAR = 1919,
  EGMI_REQ_ADD_BUILDING = 5000,
  EGMI_REQ_ACK_BUILDING_LIST = 5001,
  EGMI_REQ_STORE_BUILDING_LIST = 5010,
  EGMI_REQ_ACK_FRIEND_LIST = 6000,
  EGMI_ACK_FRIEND_DELETE = 6001,
  EGMI_ACK_FRIEND_ADD = 6002,
  EGMI_ACK_INVITE_ADD = 6003,
  EGMI_REQ_ACK_SEND_INVITE = 6010,
  EGMI_REQ_ACK_ACCEPT_INVITE = 6011,
  EGMI_REQ_ACK_REJECT_INVITE = 6012,
  EGMI_REQ_ACK_IGNORE_INVITE = 6013,
  EGMI_REQ_ACK_BLOCK_PLAYER = 6014,
  EGMI_REQ_ACK_UNBLOCK_PLAYER = 6015,
  EGMI_ACK_TEAM_INVITE = 6100,
  EGMI_ACK_TEAM_LIST = 6105,
  EGMI_ACK_TEAM_ADD = 6106,
  EGMI_ACK_TEAM_LEAVE = 6107,
  EGMI_REQ_ACK_SEND_TEAM_INVITE = 6120,
  EGMI_REQ_ACK_CANCEL_TEAM_INVITE = 6121,
  EGMI_REQ_ACK_ACCEPT_TEAM_INVITE = 6122,
  EGMI_REQ_ACK_REJECT_TEAM_INVITE = 6123,
  EGMI_REQ_ACK_SEND_TEAM_READY = 6130,
  EGMI_REQ_ACK_ACCEPT_TEAM_READY = 6131,
  EGMI_REQ_ACK_REJECT_TEAM_READY = 6132,
  EGMI_REQ_CMD_PROPERTY_INT = 10000,
  EGMI_REQ_CMD_PROPERTY_STR = 10001,
  EGMI_REQ_CMD_PROPERTY_OBJECT = 10002,
  EGMI_REQ_CMD_PROPERTY_FLOAT = 10003,
  EGMI_REQ_CMD_RECORD_INT = 10004,
  EGMI_REQ_CMD_RECORD_STR = 10005,
  EGMI_REQ_CMD_RECORD_OBJECT = 10006,
  EGMI_REQ_CMD_RECORD_FLOAT = 10007,
  EGMI_REQ_CMD_NORMAL = 10008,
  EGMI_REQ_QUERY_SERVER_STATUS = 10200,
  EGMI_REQ_BUY_FORM_SHOP = 20000,
  EGMI_ACK_BUY_FORM_SHOP = 20001,
  EGMI_REQ_MOVE_BUILD_OBJECT = 20002,
  EGMI_ACK_MOVE_BUILD_OBJECT = 20003,
  EGMI_REQ_UP_BUILD_LVL = 20101,
  EGMI_REQ_CREATE_ITEM = 20102,
  EGMI_REQ_BUILD_OPERATE = 20103,
  EGameMsgID_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  EGameMsgID_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
LIBPROTOC_EXPORT bool EGameMsgID_IsValid(int value);
constexpr EGameMsgID EGameMsgID_MIN = EGMI_UNKNOW;
constexpr EGameMsgID EGameMsgID_MAX = EGMI_REQ_BUILD_OPERATE;
constexpr int EGameMsgID_ARRAYSIZE = EGameMsgID_MAX + 1;

LIBPROTOC_EXPORT const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EGameMsgID_descriptor();
template<typename T>
inline const std::string& EGameMsgID_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EGameMsgID>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EGameMsgID_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EGameMsgID_descriptor(), enum_t_value);
}
inline bool EGameMsgID_Parse(
    const std::string& name, EGameMsgID* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EGameMsgID>(
    EGameMsgID_descriptor(), name, value);
}
enum ESkillType : int {
  EST_BRIEF_SINGLE = 0,
  EST_BRIEF_GROUP = 1,
  EST_BULLET_SINGLE = 2,
  EST_BULLET_REBOUND = 3,
  EST_BULLET_TARGET_BOMB = 4,
  EST_BULLET_POS_BOMB = 5,
  ESkillType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ESkillType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
LIBPROTOC_EXPORT bool ESkillType_IsValid(int value);
constexpr ESkillType ESkillType_MIN = EST_BRIEF_SINGLE;
constexpr ESkillType ESkillType_MAX = EST_BULLET_POS_BOMB;
constexpr int ESkillType_ARRAYSIZE = ESkillType_MAX + 1;

LIBPROTOC_EXPORT const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ESkillType_descriptor();
template<typename T>
inline const std::string& ESkillType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ESkillType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ESkillType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ESkillType_descriptor(), enum_t_value);
}
inline bool ESkillType_Parse(
    const std::string& name, ESkillType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ESkillType>(
    ESkillType_descriptor(), name, value);
}
enum EItemType : int {
  EIT_EQUIP = 0,
  EIT_GEM = 1,
  EIT_SUPPLY = 2,
  EIT_SCROLL = 3,
  EItemType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  EItemType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
LIBPROTOC_EXPORT bool EItemType_IsValid(int value);
constexpr EItemType EItemType_MIN = EIT_EQUIP;
constexpr EItemType EItemType_MAX = EIT_SCROLL;
constexpr int EItemType_ARRAYSIZE = EItemType_MAX + 1;

LIBPROTOC_EXPORT const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EItemType_descriptor();
template<typename T>
inline const std::string& EItemType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EItemType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EItemType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EItemType_descriptor(), enum_t_value);
}
inline bool EItemType_Parse(
    const std::string& name, EItemType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EItemType>(
    EItemType_descriptor(), name, value);
}
enum EGameEquipSubType : int {
  EQUIPTYPE_WEAPON = 0,
  EQUIPTYPE_HELMET = 1,
  EQUIPTYPE_ARMOR = 2,
  EQUIPTYPE_HAND = 3,
  EQUIPTYPE_RING = 4,
  EQUIPTYPE_BOOT = 5,
  EGameEquipSubType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  EGameEquipSubType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
LIBPROTOC_EXPORT bool EGameEquipSubType_IsValid(int value);
constexpr EGameEquipSubType EGameEquipSubType_MIN = EQUIPTYPE_WEAPON;
constexpr EGameEquipSubType EGameEquipSubType_MAX = EQUIPTYPE_BOOT;
constexpr int EGameEquipSubType_ARRAYSIZE = EGameEquipSubType_MAX + 1;

LIBPROTOC_EXPORT const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EGameEquipSubType_descriptor();
template<typename T>
inline const std::string& EGameEquipSubType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EGameEquipSubType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EGameEquipSubType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EGameEquipSubType_descriptor(), enum_t_value);
}
inline bool EGameEquipSubType_Parse(
    const std::string& name, EGameEquipSubType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EGameEquipSubType>(
    EGameEquipSubType_descriptor(), name, value);
}
enum EGameGemSubType : int {
  EGGSTYPE_GEM_ATK = 0,
  EGGSTYPE_GEM_DEF = 1,
  EGGSTYPE_GEM_FIRE = 3,
  EGGSTYPE_GEM_LIGHT = 4,
  EGGSTYPE_GEM_WIND = 5,
  EGGSTYPE_GEM_ICE = 6,
  EGGSTYPE_GEM_POISON = 7,
  EGGSTYPE_GEM_DRAK = 8,
  EGameGemSubType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  EGameGemSubType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
LIBPROTOC_EXPORT bool EGameGemSubType_IsValid(int value);
constexpr EGameGemSubType EGameGemSubType_MIN = EGGSTYPE_GEM_ATK;
constexpr EGameGemSubType EGameGemSubType_MAX = EGGSTYPE_GEM_DRAK;
constexpr int EGameGemSubType_ARRAYSIZE = EGameGemSubType_MAX + 1;

LIBPROTOC_EXPORT const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EGameGemSubType_descriptor();
template<typename T>
inline const std::string& EGameGemSubType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EGameGemSubType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EGameGemSubType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EGameGemSubType_descriptor(), enum_t_value);
}
inline bool EGameGemSubType_Parse(
    const std::string& name, EGameGemSubType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EGameGemSubType>(
    EGameGemSubType_descriptor(), name, value);
}
enum EGameSupplySubType : int {
  EGIT_ITEM_WATER = 0,
  EGIT_ITEM_DIAMOND = 1,
  EGIT_ITEM_CURRENCY = 2,
  EGIT_ITEM_EXP = 3,
  EGIT_ITEM_HP = 4,
  EGIT_ITEM_MP = 5,
  EGIT_ITEM_SP = 6,
  EGIT_ITEM_PACK = 7,
  EGIT_ITEM_MEMORY_POS = 8,
  EGameSupplySubType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  EGameSupplySubType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
LIBPROTOC_EXPORT bool EGameSupplySubType_IsValid(int value);
constexpr EGameSupplySubType EGameSupplySubType_MIN = EGIT_ITEM_WATER;
constexpr EGameSupplySubType EGameSupplySubType_MAX = EGIT_ITEM_MEMORY_POS;
constexpr int EGameSupplySubType_ARRAYSIZE = EGameSupplySubType_MAX + 1;

LIBPROTOC_EXPORT const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EGameSupplySubType_descriptor();
template<typename T>
inline const std::string& EGameSupplySubType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EGameSupplySubType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EGameSupplySubType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EGameSupplySubType_descriptor(), enum_t_value);
}
inline bool EGameSupplySubType_Parse(
    const std::string& name, EGameSupplySubType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EGameSupplySubType>(
    EGameSupplySubType_descriptor(), name, value);
}
enum EGameScrollSubType : int {
  EGTST_TOKEN_HERO_CARD = 0,
  EGTST_TOKEN_POSITION = 1,
  EGTST_TOKEN_BOUNTY = 2,
  EGTST_TOKEN_ACTIVITY = 3,
  EGTST_TOKEN_BUILD = 4,
  EGameScrollSubType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  EGameScrollSubType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
LIBPROTOC_EXPORT bool EGameScrollSubType_IsValid(int value);
constexpr EGameScrollSubType EGameScrollSubType_MIN = EGTST_TOKEN_HERO_CARD;
constexpr EGameScrollSubType EGameScrollSubType_MAX = EGTST_TOKEN_BUILD;
constexpr int EGameScrollSubType_ARRAYSIZE = EGameScrollSubType_MAX + 1;

LIBPROTOC_EXPORT const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EGameScrollSubType_descriptor();
template<typename T>
inline const std::string& EGameScrollSubType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EGameScrollSubType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EGameScrollSubType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EGameScrollSubType_descriptor(), enum_t_value);
}
inline bool EGameScrollSubType_Parse(
    const std::string& name, EGameScrollSubType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EGameScrollSubType>(
    EGameScrollSubType_descriptor(), name, value);
}
enum EGameItemExpiredType : int {
  EGIET_NONE = 0,
  EGIET_USE_TIMES = 1,
  EGIET_REAL_TIME = 2,
  EGIET_END_INDEX = 3,
  EGameItemExpiredType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  EGameItemExpiredType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
LIBPROTOC_EXPORT bool EGameItemExpiredType_IsValid(int value);
constexpr EGameItemExpiredType EGameItemExpiredType_MIN = EGIET_NONE;
constexpr EGameItemExpiredType EGameItemExpiredType_MAX = EGIET_END_INDEX;
constexpr int EGameItemExpiredType_ARRAYSIZE = EGameItemExpiredType_MAX + 1;

LIBPROTOC_EXPORT const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EGameItemExpiredType_descriptor();
template<typename T>
inline const std::string& EGameItemExpiredType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EGameItemExpiredType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EGameItemExpiredType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EGameItemExpiredType_descriptor(), enum_t_value);
}
inline bool EGameItemExpiredType_Parse(
    const std::string& name, EGameItemExpiredType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EGameItemExpiredType>(
    EGameItemExpiredType_descriptor(), name, value);
}
enum EDrawDropItemState : int {
  E_DRAW_STATE_NONE = 0,
  E_DRAW_STATE_GAIN = 1,
  E_DRAW_STATE_RECV = 2,
  EDrawDropItemState_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  EDrawDropItemState_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
LIBPROTOC_EXPORT bool EDrawDropItemState_IsValid(int value);
constexpr EDrawDropItemState EDrawDropItemState_MIN = E_DRAW_STATE_NONE;
constexpr EDrawDropItemState EDrawDropItemState_MAX = E_DRAW_STATE_RECV;
constexpr int EDrawDropItemState_ARRAYSIZE = EDrawDropItemState_MAX + 1;

LIBPROTOC_EXPORT const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EDrawDropItemState_descriptor();
template<typename T>
inline const std::string& EDrawDropItemState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EDrawDropItemState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EDrawDropItemState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EDrawDropItemState_descriptor(), enum_t_value);
}
inline bool EDrawDropItemState_Parse(
    const std::string& name, EDrawDropItemState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EDrawDropItemState>(
    EDrawDropItemState_descriptor(), name, value);
}
enum EGuildPowerType : int {
  CLAN_POWER_TYPE_NORMAL = 0,
  CLAN_POWER_TYPE_VICE_PRESIDENT = 1,
  CLAN_POWER_TYPE_PRESIDENT = 2,
  EGuildPowerType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  EGuildPowerType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
LIBPROTOC_EXPORT bool EGuildPowerType_IsValid(int value);
constexpr EGuildPowerType EGuildPowerType_MIN = CLAN_POWER_TYPE_NORMAL;
constexpr EGuildPowerType EGuildPowerType_MAX = CLAN_POWER_TYPE_PRESIDENT;
constexpr int EGuildPowerType_ARRAYSIZE = EGuildPowerType_MAX + 1;

LIBPROTOC_EXPORT const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EGuildPowerType_descriptor();
template<typename T>
inline const std::string& EGuildPowerType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EGuildPowerType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EGuildPowerType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EGuildPowerType_descriptor(), enum_t_value);
}
inline bool EGuildPowerType_Parse(
    const std::string& name, EGuildPowerType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EGuildPowerType>(
    EGuildPowerType_descriptor(), name, value);
}
enum ETaskState : int {
  TASK_IN_PROCESS = 0,
  TASK_DONE = 1,
  TASK_DRAW_AWARD = 2,
  TASK_FINISH = 3,
  ETaskState_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ETaskState_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
LIBPROTOC_EXPORT bool ETaskState_IsValid(int value);
constexpr ETaskState ETaskState_MIN = TASK_IN_PROCESS;
constexpr ETaskState ETaskState_MAX = TASK_FINISH;
constexpr int ETaskState_ARRAYSIZE = ETaskState_MAX + 1;

LIBPROTOC_EXPORT const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ETaskState_descriptor();
template<typename T>
inline const std::string& ETaskState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ETaskState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ETaskState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ETaskState_descriptor(), enum_t_value);
}
inline bool ETaskState_Parse(
    const std::string& name, ETaskState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ETaskState>(
    ETaskState_descriptor(), name, value);
}
enum ETaskType : int {
  TASK_LEVEL_UPDATE_SOME_LEVEL = 0,
  TASK_PASS_ECTYPE = 1,
  TASK_PASS_ECTYPE_COUNT = 2,
  TASK_PASS_SOME_TYPE_ECTYPE_COUNT = 3,
  TASK_UPDATE_SKILL_COUNT = 4,
  TASK_CONSUME_MONEY = 5,
  TASK_CONSUME_DIAMOND = 6,
  TASK_ARENA_COUNT = 7,
  TASK_KILL_MONSTER_COUNT = 8,
  TASK_KILL_SOME_MONSTER_COUNT = 9,
  ETaskType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ETaskType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
LIBPROTOC_EXPORT bool ETaskType_IsValid(int value);
constexpr ETaskType ETaskType_MIN = TASK_LEVEL_UPDATE_SOME_LEVEL;
constexpr ETaskType ETaskType_MAX = TASK_KILL_SOME_MONSTER_COUNT;
constexpr int ETaskType_ARRAYSIZE = ETaskType_MAX + 1;

LIBPROTOC_EXPORT const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ETaskType_descriptor();
template<typename T>
inline const std::string& ETaskType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ETaskType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ETaskType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ETaskType_descriptor(), enum_t_value);
}
inline bool ETaskType_Parse(
    const std::string& name, ETaskType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ETaskType>(
    ETaskType_descriptor(), name, value);
}
enum ESceneType : int {
  SCENE_NORMAL = 0,
  SCENE_SINGLE_CLONE = 1,
  SCENE_MULTI_CLONE = 2,
  SCENE_HOME = 3,
  SCENE_CLAN = 4,
  ESceneType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ESceneType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
LIBPROTOC_EXPORT bool ESceneType_IsValid(int value);
constexpr ESceneType ESceneType_MIN = SCENE_NORMAL;
constexpr ESceneType ESceneType_MAX = SCENE_CLAN;
constexpr int ESceneType_ARRAYSIZE = ESceneType_MAX + 1;

LIBPROTOC_EXPORT const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ESceneType_descriptor();
template<typename T>
inline const std::string& ESceneType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ESceneType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ESceneType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ESceneType_descriptor(), enum_t_value);
}
inline bool ESceneType_Parse(
    const std::string& name, ESceneType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ESceneType>(
    ESceneType_descriptor(), name, value);
}
enum EPVPType : int {
  PVP_HOME = 0,
  PVP_INDIVIDUAL = 1,
  PVP_DOTA = 2,
  PVP_SURVIVAL = 3,
  PVP_CLAN_WAR = 4,
  PVP_CLAN_DUNGEON = 5,
  EPVPType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  EPVPType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
LIBPROTOC_EXPORT bool EPVPType_IsValid(int value);
constexpr EPVPType EPVPType_MIN = PVP_HOME;
constexpr EPVPType EPVPType_MAX = PVP_CLAN_DUNGEON;
constexpr int EPVPType_ARRAYSIZE = EPVPType_MAX + 1;

LIBPROTOC_EXPORT const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EPVPType_descriptor();
template<typename T>
inline const std::string& EPVPType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EPVPType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EPVPType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EPVPType_descriptor(), enum_t_value);
}
inline bool EPVPType_Parse(
    const std::string& name, EPVPType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EPVPType>(
    EPVPType_descriptor(), name, value);
}
enum EShopType : int {
  EST_UNKNOW = 0,
  EST_BUILDING = 1,
  EST_GOLD = 2,
  EST_ITEM = 3,
  EST_EQUIP = 5,
  EST_GEM = 6,
  EST_CARD = 7,
  EShopType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  EShopType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
LIBPROTOC_EXPORT bool EShopType_IsValid(int value);
constexpr EShopType EShopType_MIN = EST_UNKNOW;
constexpr EShopType EShopType_MAX = EST_CARD;
constexpr int EShopType_ARRAYSIZE = EShopType_MAX + 1;

LIBPROTOC_EXPORT const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EShopType_descriptor();
template<typename T>
inline const std::string& EShopType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EShopType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EShopType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EShopType_descriptor(), enum_t_value);
}
inline bool EShopType_Parse(
    const std::string& name, EShopType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EShopType>(
    EShopType_descriptor(), name, value);
}
enum ERankType : int {
  ERT_UNKNOW = 0,
  ERT_PLAYER_LEVEL = 1,
  ERT_FIGHT_VALUE = 2,
  ERT_PLAYER_MONEY = 3,
  ERT_CLAN_LEVEL = 4,
  ERT_CLAN_KINGSOURCE = 5,
  ERankType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ERankType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
LIBPROTOC_EXPORT bool ERankType_IsValid(int value);
constexpr ERankType ERankType_MIN = ERT_UNKNOW;
constexpr ERankType ERankType_MAX = ERT_CLAN_KINGSOURCE;
constexpr int ERankType_ARRAYSIZE = ERankType_MAX + 1;

LIBPROTOC_EXPORT const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ERankType_descriptor();
template<typename T>
inline const std::string& ERankType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ERankType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ERankType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ERankType_descriptor(), enum_t_value);
}
inline bool ERankType_Parse(
    const std::string& name, ERankType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ERankType>(
    ERankType_descriptor(), name, value);
}
enum ENPCType : int {
  ENPCTYPE_NORMAL = 0,
  ENPCTYPE_HERO = 1,
  ENPCTYPE_TURRET = 2,
  ENPCType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ENPCType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
LIBPROTOC_EXPORT bool ENPCType_IsValid(int value);
constexpr ENPCType ENPCType_MIN = ENPCTYPE_NORMAL;
constexpr ENPCType ENPCType_MAX = ENPCTYPE_TURRET;
constexpr int ENPCType_ARRAYSIZE = ENPCType_MAX + 1;

LIBPROTOC_EXPORT const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ENPCType_descriptor();
template<typename T>
inline const std::string& ENPCType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ENPCType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ENPCType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ENPCType_descriptor(), enum_t_value);
}
inline bool ENPCType_Parse(
    const std::string& name, ENPCType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ENPCType>(
    ENPCType_descriptor(), name, value);
}
enum ESubNPCType_TURRET : int {
  ENPCTYPE_SUB_STORAGE = 0,
  ENPCTYPE_SUB_WEAPONE = 1,
  ENPCTYPE_SUB_GUARD = 2,
  ENPCTYPE_SUB_BOMB = 3,
  ENPCTYPE_SUB_TRAP = 4,
  ESubNPCType_TURRET_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ESubNPCType_TURRET_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
LIBPROTOC_EXPORT bool ESubNPCType_TURRET_IsValid(int value);
constexpr ESubNPCType_TURRET ESubNPCType_TURRET_MIN = ENPCTYPE_SUB_STORAGE;
constexpr ESubNPCType_TURRET ESubNPCType_TURRET_MAX = ENPCTYPE_SUB_TRAP;
constexpr int ESubNPCType_TURRET_ARRAYSIZE = ESubNPCType_TURRET_MAX + 1;

LIBPROTOC_EXPORT const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ESubNPCType_TURRET_descriptor();
template<typename T>
inline const std::string& ESubNPCType_TURRET_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ESubNPCType_TURRET>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ESubNPCType_TURRET_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ESubNPCType_TURRET_descriptor(), enum_t_value);
}
inline bool ESubNPCType_TURRET_Parse(
    const std::string& name, ESubNPCType_TURRET* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ESubNPCType_TURRET>(
    ESubNPCType_TURRET_descriptor(), name, value);
}
enum EMeleeType : int {
  ETYPE_MELEE = 0,
  ETYPE_MELEE_DASH = 1,
  ETYPE_RANGER = 2,
  EMeleeType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  EMeleeType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
LIBPROTOC_EXPORT bool EMeleeType_IsValid(int value);
constexpr EMeleeType EMeleeType_MIN = ETYPE_MELEE;
constexpr EMeleeType EMeleeType_MAX = ETYPE_RANGER;
constexpr int EMeleeType_ARRAYSIZE = EMeleeType_MAX + 1;

LIBPROTOC_EXPORT const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EMeleeType_descriptor();
template<typename T>
inline const std::string& EMeleeType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EMeleeType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EMeleeType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EMeleeType_descriptor(), enum_t_value);
}
inline bool EMeleeType_Parse(
    const std::string& name, EMeleeType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EMeleeType>(
    EMeleeType_descriptor(), name, value);
}
enum EEffectObjType : int {
  ETARGETTYPE_ENEMY = 0,
  ETARGETTYPE_SELF = 1,
  ETARGETTYPE_FRIEND = 2,
  EEffectObjType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  EEffectObjType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
LIBPROTOC_EXPORT bool EEffectObjType_IsValid(int value);
constexpr EEffectObjType EEffectObjType_MIN = ETARGETTYPE_ENEMY;
constexpr EEffectObjType EEffectObjType_MAX = ETARGETTYPE_FRIEND;
constexpr int EEffectObjType_ARRAYSIZE = EEffectObjType_MAX + 1;

LIBPROTOC_EXPORT const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EEffectObjType_descriptor();
template<typename T>
inline const std::string& EEffectObjType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EEffectObjType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EEffectObjType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EEffectObjType_descriptor(), enum_t_value);
}
inline bool EEffectObjType_Parse(
    const std::string& name, EEffectObjType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EEffectObjType>(
    EEffectObjType_descriptor(), name, value);
}
enum EPropertyType : int {
  EPT_UNKNOW = 0,
  EPT_STRENGTH = 1,
  EPT_AGILITY = 2,
  EPT_INTELLIGENCE = 3,
  EPropertyType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  EPropertyType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
LIBPROTOC_EXPORT bool EPropertyType_IsValid(int value);
constexpr EPropertyType EPropertyType_MIN = EPT_UNKNOW;
constexpr EPropertyType EPropertyType_MAX = EPT_INTELLIGENCE;
constexpr int EPropertyType_ARRAYSIZE = EPropertyType_MAX + 1;

LIBPROTOC_EXPORT const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EPropertyType_descriptor();
template<typename T>
inline const std::string& EPropertyType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EPropertyType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EPropertyType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EPropertyType_descriptor(), enum_t_value);
}
inline bool EPropertyType_Parse(
    const std::string& name, EPropertyType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EPropertyType>(
    EPropertyType_descriptor(), name, value);
}
enum EGameElementType : int {
  EELEMENTTYPE_FIRE = 0,
  EELEMENTTYPE_LIGHT = 1,
  EELEMENTTYPE_WIND = 2,
  EELEMENTTYPE_ICE = 3,
  EELEMENTTYPE_POISON = 4,
  EELEMENTTYPE_DARK = 5,
  EGameElementType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  EGameElementType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
LIBPROTOC_EXPORT bool EGameElementType_IsValid(int value);
constexpr EGameElementType EGameElementType_MIN = EELEMENTTYPE_FIRE;
constexpr EGameElementType EGameElementType_MAX = EELEMENTTYPE_DARK;
constexpr int EGameElementType_ARRAYSIZE = EGameElementType_MAX + 1;

LIBPROTOC_EXPORT const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EGameElementType_descriptor();
template<typename T>
inline const std::string& EGameElementType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EGameElementType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EGameElementType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EGameElementType_descriptor(), enum_t_value);
}
inline bool EGameElementType_Parse(
    const std::string& name, EGameElementType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EGameElementType>(
    EGameElementType_descriptor(), name, value);
}
enum EBattleType : int {
  EBT_SINGLE_MODE = 0,
  EBT_MULTI_MODE = 1,
  EBT_CLAN_MODE = 2,
  EBT_CLAN_BOSS_MODE = 3,
  EBT_WORLD_BOSS_MODE = 4,
  EBT_MOBA_MODE = 5,
  EBT_SURVIVAL_MODE = 6,
  EBattleType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  EBattleType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
LIBPROTOC_EXPORT bool EBattleType_IsValid(int value);
constexpr EBattleType EBattleType_MIN = EBT_SINGLE_MODE;
constexpr EBattleType EBattleType_MAX = EBT_SURVIVAL_MODE;
constexpr int EBattleType_ARRAYSIZE = EBattleType_MAX + 1;

LIBPROTOC_EXPORT const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EBattleType_descriptor();
template<typename T>
inline const std::string& EBattleType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EBattleType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EBattleType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EBattleType_descriptor(), enum_t_value);
}
inline bool EBattleType_Parse(
    const std::string& name, EBattleType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EBattleType>(
    EBattleType_descriptor(), name, value);
}
// ===================================================================


// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)

}  // namespace NFMsg

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::NFMsg::EGameEventCode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::NFMsg::EGameEventCode>() {
  return ::NFMsg::EGameEventCode_descriptor();
}
template <> struct is_proto_enum< ::NFMsg::ESynMsgID> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::NFMsg::ESynMsgID>() {
  return ::NFMsg::ESynMsgID_descriptor();
}
template <> struct is_proto_enum< ::NFMsg::EGameMsgID> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::NFMsg::EGameMsgID>() {
  return ::NFMsg::EGameMsgID_descriptor();
}
template <> struct is_proto_enum< ::NFMsg::ESkillType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::NFMsg::ESkillType>() {
  return ::NFMsg::ESkillType_descriptor();
}
template <> struct is_proto_enum< ::NFMsg::EItemType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::NFMsg::EItemType>() {
  return ::NFMsg::EItemType_descriptor();
}
template <> struct is_proto_enum< ::NFMsg::EGameEquipSubType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::NFMsg::EGameEquipSubType>() {
  return ::NFMsg::EGameEquipSubType_descriptor();
}
template <> struct is_proto_enum< ::NFMsg::EGameGemSubType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::NFMsg::EGameGemSubType>() {
  return ::NFMsg::EGameGemSubType_descriptor();
}
template <> struct is_proto_enum< ::NFMsg::EGameSupplySubType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::NFMsg::EGameSupplySubType>() {
  return ::NFMsg::EGameSupplySubType_descriptor();
}
template <> struct is_proto_enum< ::NFMsg::EGameScrollSubType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::NFMsg::EGameScrollSubType>() {
  return ::NFMsg::EGameScrollSubType_descriptor();
}
template <> struct is_proto_enum< ::NFMsg::EGameItemExpiredType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::NFMsg::EGameItemExpiredType>() {
  return ::NFMsg::EGameItemExpiredType_descriptor();
}
template <> struct is_proto_enum< ::NFMsg::EDrawDropItemState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::NFMsg::EDrawDropItemState>() {
  return ::NFMsg::EDrawDropItemState_descriptor();
}
template <> struct is_proto_enum< ::NFMsg::EGuildPowerType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::NFMsg::EGuildPowerType>() {
  return ::NFMsg::EGuildPowerType_descriptor();
}
template <> struct is_proto_enum< ::NFMsg::ETaskState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::NFMsg::ETaskState>() {
  return ::NFMsg::ETaskState_descriptor();
}
template <> struct is_proto_enum< ::NFMsg::ETaskType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::NFMsg::ETaskType>() {
  return ::NFMsg::ETaskType_descriptor();
}
template <> struct is_proto_enum< ::NFMsg::ESceneType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::NFMsg::ESceneType>() {
  return ::NFMsg::ESceneType_descriptor();
}
template <> struct is_proto_enum< ::NFMsg::EPVPType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::NFMsg::EPVPType>() {
  return ::NFMsg::EPVPType_descriptor();
}
template <> struct is_proto_enum< ::NFMsg::EShopType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::NFMsg::EShopType>() {
  return ::NFMsg::EShopType_descriptor();
}
template <> struct is_proto_enum< ::NFMsg::ERankType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::NFMsg::ERankType>() {
  return ::NFMsg::ERankType_descriptor();
}
template <> struct is_proto_enum< ::NFMsg::ENPCType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::NFMsg::ENPCType>() {
  return ::NFMsg::ENPCType_descriptor();
}
template <> struct is_proto_enum< ::NFMsg::ESubNPCType_TURRET> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::NFMsg::ESubNPCType_TURRET>() {
  return ::NFMsg::ESubNPCType_TURRET_descriptor();
}
template <> struct is_proto_enum< ::NFMsg::EMeleeType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::NFMsg::EMeleeType>() {
  return ::NFMsg::EMeleeType_descriptor();
}
template <> struct is_proto_enum< ::NFMsg::EEffectObjType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::NFMsg::EEffectObjType>() {
  return ::NFMsg::EEffectObjType_descriptor();
}
template <> struct is_proto_enum< ::NFMsg::EPropertyType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::NFMsg::EPropertyType>() {
  return ::NFMsg::EPropertyType_descriptor();
}
template <> struct is_proto_enum< ::NFMsg::EGameElementType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::NFMsg::EGameElementType>() {
  return ::NFMsg::EGameElementType_descriptor();
}
template <> struct is_proto_enum< ::NFMsg::EBattleType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::NFMsg::EBattleType>() {
  return ::NFMsg::EBattleType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_NFDefine_2eproto
