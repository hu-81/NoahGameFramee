// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: NFMsgExtra.proto

#ifndef PROTOBUF_INCLUDED_NFMsgExtra_2eproto
#define PROTOBUF_INCLUDED_NFMsgExtra_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "NFMsgBase.pb.h"
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_NFMsgExtra_2eproto LIBPROTOC_EXPORT

namespace protobuf_NFMsgExtra_2eproto {
// Internal implementation detail -- do not use these members.
struct LIBPROTOC_EXPORT TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[20];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void LIBPROTOC_EXPORT AddDescriptors();
}  // namespace protobuf_NFMsgExtra_2eproto
namespace NFMsg {
class AckBigMapGridInfo;
class AckBigMapGridInfoDefaultTypeInternal;
LIBPROTOC_EXPORT extern AckBigMapGridInfoDefaultTypeInternal _AckBigMapGridInfo_default_instance_;
class AckBigMapInfo;
class AckBigMapInfoDefaultTypeInternal;
LIBPROTOC_EXPORT extern AckBigMapInfoDefaultTypeInternal _AckBigMapInfo_default_instance_;
class AckGetMapAward;
class AckGetMapAwardDefaultTypeInternal;
LIBPROTOC_EXPORT extern AckGetMapAwardDefaultTypeInternal _AckGetMapAward_default_instance_;
class AckHoldMapGrid;
class AckHoldMapGridDefaultTypeInternal;
LIBPROTOC_EXPORT extern AckHoldMapGridDefaultTypeInternal _AckHoldMapGrid_default_instance_;
class AckLeaveMapMsg;
class AckLeaveMapMsgDefaultTypeInternal;
LIBPROTOC_EXPORT extern AckLeaveMapMsgDefaultTypeInternal _AckLeaveMapMsg_default_instance_;
class AckMapHunting;
class AckMapHuntingDefaultTypeInternal;
LIBPROTOC_EXPORT extern AckMapHuntingDefaultTypeInternal _AckMapHunting_default_instance_;
class AckMapKingWar;
class AckMapKingWarDefaultTypeInternal;
LIBPROTOC_EXPORT extern AckMapKingWarDefaultTypeInternal _AckMapKingWar_default_instance_;
class BigMapGridBaseInfo;
class BigMapGridBaseInfoDefaultTypeInternal;
LIBPROTOC_EXPORT extern BigMapGridBaseInfoDefaultTypeInternal _BigMapGridBaseInfo_default_instance_;
class BigMapGridDetailInfo;
class BigMapGridDetailInfoDefaultTypeInternal;
LIBPROTOC_EXPORT extern BigMapGridDetailInfoDefaultTypeInternal _BigMapGridDetailInfo_default_instance_;
class BigMapLeaveMsg;
class BigMapLeaveMsgDefaultTypeInternal;
LIBPROTOC_EXPORT extern BigMapLeaveMsgDefaultTypeInternal _BigMapLeaveMsg_default_instance_;
class BigMapWarHistory;
class BigMapWarHistoryDefaultTypeInternal;
LIBPROTOC_EXPORT extern BigMapWarHistoryDefaultTypeInternal _BigMapWarHistory_default_instance_;
class GridClanBaseInfo;
class GridClanBaseInfoDefaultTypeInternal;
LIBPROTOC_EXPORT extern GridClanBaseInfoDefaultTypeInternal _GridClanBaseInfo_default_instance_;
class ReqAIOnwer;
class ReqAIOnwerDefaultTypeInternal;
LIBPROTOC_EXPORT extern ReqAIOnwerDefaultTypeInternal _ReqAIOnwer_default_instance_;
class ReqBigMapGridInfo;
class ReqBigMapGridInfoDefaultTypeInternal;
LIBPROTOC_EXPORT extern ReqBigMapGridInfoDefaultTypeInternal _ReqBigMapGridInfo_default_instance_;
class ReqBigMapInfo;
class ReqBigMapInfoDefaultTypeInternal;
LIBPROTOC_EXPORT extern ReqBigMapInfoDefaultTypeInternal _ReqBigMapInfo_default_instance_;
class ReqGetMapAward;
class ReqGetMapAwardDefaultTypeInternal;
LIBPROTOC_EXPORT extern ReqGetMapAwardDefaultTypeInternal _ReqGetMapAward_default_instance_;
class ReqHoldMapGrid;
class ReqHoldMapGridDefaultTypeInternal;
LIBPROTOC_EXPORT extern ReqHoldMapGridDefaultTypeInternal _ReqHoldMapGrid_default_instance_;
class ReqLeaveMapMsg;
class ReqLeaveMapMsgDefaultTypeInternal;
LIBPROTOC_EXPORT extern ReqLeaveMapMsgDefaultTypeInternal _ReqLeaveMapMsg_default_instance_;
class ReqMapHunting;
class ReqMapHuntingDefaultTypeInternal;
LIBPROTOC_EXPORT extern ReqMapHuntingDefaultTypeInternal _ReqMapHunting_default_instance_;
class ReqMapKingWar;
class ReqMapKingWarDefaultTypeInternal;
LIBPROTOC_EXPORT extern ReqMapKingWarDefaultTypeInternal _ReqMapKingWar_default_instance_;
}  // namespace NFMsg
namespace google {
namespace protobuf {
template<> LIBPROTOC_EXPORT ::NFMsg::AckBigMapGridInfo* Arena::CreateMaybeMessage<::NFMsg::AckBigMapGridInfo>(Arena*);
template<> LIBPROTOC_EXPORT ::NFMsg::AckBigMapInfo* Arena::CreateMaybeMessage<::NFMsg::AckBigMapInfo>(Arena*);
template<> LIBPROTOC_EXPORT ::NFMsg::AckGetMapAward* Arena::CreateMaybeMessage<::NFMsg::AckGetMapAward>(Arena*);
template<> LIBPROTOC_EXPORT ::NFMsg::AckHoldMapGrid* Arena::CreateMaybeMessage<::NFMsg::AckHoldMapGrid>(Arena*);
template<> LIBPROTOC_EXPORT ::NFMsg::AckLeaveMapMsg* Arena::CreateMaybeMessage<::NFMsg::AckLeaveMapMsg>(Arena*);
template<> LIBPROTOC_EXPORT ::NFMsg::AckMapHunting* Arena::CreateMaybeMessage<::NFMsg::AckMapHunting>(Arena*);
template<> LIBPROTOC_EXPORT ::NFMsg::AckMapKingWar* Arena::CreateMaybeMessage<::NFMsg::AckMapKingWar>(Arena*);
template<> LIBPROTOC_EXPORT ::NFMsg::BigMapGridBaseInfo* Arena::CreateMaybeMessage<::NFMsg::BigMapGridBaseInfo>(Arena*);
template<> LIBPROTOC_EXPORT ::NFMsg::BigMapGridDetailInfo* Arena::CreateMaybeMessage<::NFMsg::BigMapGridDetailInfo>(Arena*);
template<> LIBPROTOC_EXPORT ::NFMsg::BigMapLeaveMsg* Arena::CreateMaybeMessage<::NFMsg::BigMapLeaveMsg>(Arena*);
template<> LIBPROTOC_EXPORT ::NFMsg::BigMapWarHistory* Arena::CreateMaybeMessage<::NFMsg::BigMapWarHistory>(Arena*);
template<> LIBPROTOC_EXPORT ::NFMsg::GridClanBaseInfo* Arena::CreateMaybeMessage<::NFMsg::GridClanBaseInfo>(Arena*);
template<> LIBPROTOC_EXPORT ::NFMsg::ReqAIOnwer* Arena::CreateMaybeMessage<::NFMsg::ReqAIOnwer>(Arena*);
template<> LIBPROTOC_EXPORT ::NFMsg::ReqBigMapGridInfo* Arena::CreateMaybeMessage<::NFMsg::ReqBigMapGridInfo>(Arena*);
template<> LIBPROTOC_EXPORT ::NFMsg::ReqBigMapInfo* Arena::CreateMaybeMessage<::NFMsg::ReqBigMapInfo>(Arena*);
template<> LIBPROTOC_EXPORT ::NFMsg::ReqGetMapAward* Arena::CreateMaybeMessage<::NFMsg::ReqGetMapAward>(Arena*);
template<> LIBPROTOC_EXPORT ::NFMsg::ReqHoldMapGrid* Arena::CreateMaybeMessage<::NFMsg::ReqHoldMapGrid>(Arena*);
template<> LIBPROTOC_EXPORT ::NFMsg::ReqLeaveMapMsg* Arena::CreateMaybeMessage<::NFMsg::ReqLeaveMapMsg>(Arena*);
template<> LIBPROTOC_EXPORT ::NFMsg::ReqMapHunting* Arena::CreateMaybeMessage<::NFMsg::ReqMapHunting>(Arena*);
template<> LIBPROTOC_EXPORT ::NFMsg::ReqMapKingWar* Arena::CreateMaybeMessage<::NFMsg::ReqMapKingWar>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace NFMsg {

// ===================================================================

class LIBPROTOC_EXPORT ReqAIOnwer : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NFMsg.ReqAIOnwer) */ {
 public:
  ReqAIOnwer();
  virtual ~ReqAIOnwer();

  ReqAIOnwer(const ReqAIOnwer& from);

  inline ReqAIOnwer& operator=(const ReqAIOnwer& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ReqAIOnwer(ReqAIOnwer&& from) noexcept
    : ReqAIOnwer() {
    *this = ::std::move(from);
  }

  inline ReqAIOnwer& operator=(ReqAIOnwer&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqAIOnwer& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReqAIOnwer* internal_default_instance() {
    return reinterpret_cast<const ReqAIOnwer*>(
               &_ReqAIOnwer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(ReqAIOnwer* other);
  friend void swap(ReqAIOnwer& a, ReqAIOnwer& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ReqAIOnwer* New() const final {
    return CreateMaybeMessage<ReqAIOnwer>(NULL);
  }

  ReqAIOnwer* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ReqAIOnwer>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ReqAIOnwer& from);
  void MergeFrom(const ReqAIOnwer& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReqAIOnwer* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .NFMsg.Ident ai_id = 1;
  bool has_ai_id() const;
  void clear_ai_id();
  static const int kAiIdFieldNumber = 1;
  private:
  const ::NFMsg::Ident& _internal_ai_id() const;
  public:
  const ::NFMsg::Ident& ai_id() const;
  ::NFMsg::Ident* release_ai_id();
  ::NFMsg::Ident* mutable_ai_id();
  void set_allocated_ai_id(::NFMsg::Ident* ai_id);

  // @@protoc_insertion_point(class_scope:NFMsg.ReqAIOnwer)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::NFMsg::Ident* ai_id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_NFMsgExtra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LIBPROTOC_EXPORT GridClanBaseInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NFMsg.GridClanBaseInfo) */ {
 public:
  GridClanBaseInfo();
  virtual ~GridClanBaseInfo();

  GridClanBaseInfo(const GridClanBaseInfo& from);

  inline GridClanBaseInfo& operator=(const GridClanBaseInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GridClanBaseInfo(GridClanBaseInfo&& from) noexcept
    : GridClanBaseInfo() {
    *this = ::std::move(from);
  }

  inline GridClanBaseInfo& operator=(GridClanBaseInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GridClanBaseInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GridClanBaseInfo* internal_default_instance() {
    return reinterpret_cast<const GridClanBaseInfo*>(
               &_GridClanBaseInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(GridClanBaseInfo* other);
  friend void swap(GridClanBaseInfo& a, GridClanBaseInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GridClanBaseInfo* New() const final {
    return CreateMaybeMessage<GridClanBaseInfo>(NULL);
  }

  GridClanBaseInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GridClanBaseInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GridClanBaseInfo& from);
  void MergeFrom(const GridClanBaseInfo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GridClanBaseInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes icon = 5;
  void clear_icon();
  static const int kIconFieldNumber = 5;
  const ::std::string& icon() const;
  void set_icon(const ::std::string& value);
  #if LANG_CXX11
  void set_icon(::std::string&& value);
  #endif
  void set_icon(const char* value);
  void set_icon(const void* value, size_t size);
  ::std::string* mutable_icon();
  ::std::string* release_icon();
  void set_allocated_icon(::std::string* icon);

  // .NFMsg.Ident id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  private:
  const ::NFMsg::Ident& _internal_id() const;
  public:
  const ::NFMsg::Ident& id() const;
  ::NFMsg::Ident* release_id();
  ::NFMsg::Ident* mutable_id();
  void set_allocated_id(::NFMsg::Ident* id);

  // int32 level = 2;
  void clear_level();
  static const int kLevelFieldNumber = 2;
  ::google::protobuf::int32 level() const;
  void set_level(::google::protobuf::int32 value);

  // int32 count = 3;
  void clear_count();
  static const int kCountFieldNumber = 3;
  ::google::protobuf::int32 count() const;
  void set_count(::google::protobuf::int32 value);

  // int32 resource = 4;
  void clear_resource();
  static const int kResourceFieldNumber = 4;
  ::google::protobuf::int32 resource() const;
  void set_resource(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:NFMsg.GridClanBaseInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr icon_;
  ::NFMsg::Ident* id_;
  ::google::protobuf::int32 level_;
  ::google::protobuf::int32 count_;
  ::google::protobuf::int32 resource_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_NFMsgExtra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LIBPROTOC_EXPORT ReqBigMapGridInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NFMsg.ReqBigMapGridInfo) */ {
 public:
  ReqBigMapGridInfo();
  virtual ~ReqBigMapGridInfo();

  ReqBigMapGridInfo(const ReqBigMapGridInfo& from);

  inline ReqBigMapGridInfo& operator=(const ReqBigMapGridInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ReqBigMapGridInfo(ReqBigMapGridInfo&& from) noexcept
    : ReqBigMapGridInfo() {
    *this = ::std::move(from);
  }

  inline ReqBigMapGridInfo& operator=(ReqBigMapGridInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqBigMapGridInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReqBigMapGridInfo* internal_default_instance() {
    return reinterpret_cast<const ReqBigMapGridInfo*>(
               &_ReqBigMapGridInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(ReqBigMapGridInfo* other);
  friend void swap(ReqBigMapGridInfo& a, ReqBigMapGridInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ReqBigMapGridInfo* New() const final {
    return CreateMaybeMessage<ReqBigMapGridInfo>(NULL);
  }

  ReqBigMapGridInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ReqBigMapGridInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ReqBigMapGridInfo& from);
  void MergeFrom(const ReqBigMapGridInfo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReqBigMapGridInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated bytes map_title_id = 1;
  int map_title_id_size() const;
  void clear_map_title_id();
  static const int kMapTitleIdFieldNumber = 1;
  const ::std::string& map_title_id(int index) const;
  ::std::string* mutable_map_title_id(int index);
  void set_map_title_id(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_map_title_id(int index, ::std::string&& value);
  #endif
  void set_map_title_id(int index, const char* value);
  void set_map_title_id(int index, const void* value, size_t size);
  ::std::string* add_map_title_id();
  void add_map_title_id(const ::std::string& value);
  #if LANG_CXX11
  void add_map_title_id(::std::string&& value);
  #endif
  void add_map_title_id(const char* value);
  void add_map_title_id(const void* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& map_title_id() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_map_title_id();

  // @@protoc_insertion_point(class_scope:NFMsg.ReqBigMapGridInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> map_title_id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_NFMsgExtra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LIBPROTOC_EXPORT BigMapGridBaseInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NFMsg.BigMapGridBaseInfo) */ {
 public:
  BigMapGridBaseInfo();
  virtual ~BigMapGridBaseInfo();

  BigMapGridBaseInfo(const BigMapGridBaseInfo& from);

  inline BigMapGridBaseInfo& operator=(const BigMapGridBaseInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BigMapGridBaseInfo(BigMapGridBaseInfo&& from) noexcept
    : BigMapGridBaseInfo() {
    *this = ::std::move(from);
  }

  inline BigMapGridBaseInfo& operator=(BigMapGridBaseInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const BigMapGridBaseInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BigMapGridBaseInfo* internal_default_instance() {
    return reinterpret_cast<const BigMapGridBaseInfo*>(
               &_BigMapGridBaseInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(BigMapGridBaseInfo* other);
  friend void swap(BigMapGridBaseInfo& a, BigMapGridBaseInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BigMapGridBaseInfo* New() const final {
    return CreateMaybeMessage<BigMapGridBaseInfo>(NULL);
  }

  BigMapGridBaseInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BigMapGridBaseInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BigMapGridBaseInfo& from);
  void MergeFrom(const BigMapGridBaseInfo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BigMapGridBaseInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const void* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // .NFMsg.GridClanBaseInfo guild_info = 2;
  bool has_guild_info() const;
  void clear_guild_info();
  static const int kGuildInfoFieldNumber = 2;
  private:
  const ::NFMsg::GridClanBaseInfo& _internal_guild_info() const;
  public:
  const ::NFMsg::GridClanBaseInfo& guild_info() const;
  ::NFMsg::GridClanBaseInfo* release_guild_info();
  ::NFMsg::GridClanBaseInfo* mutable_guild_info();
  void set_allocated_guild_info(::NFMsg::GridClanBaseInfo* guild_info);

  // .NFMsg.Ident kingwarrer = 11;
  bool has_kingwarrer() const;
  void clear_kingwarrer();
  static const int kKingwarrerFieldNumber = 11;
  private:
  const ::NFMsg::Ident& _internal_kingwarrer() const;
  public:
  const ::NFMsg::Ident& kingwarrer() const;
  ::NFMsg::Ident* release_kingwarrer();
  ::NFMsg::Ident* mutable_kingwarrer();
  void set_allocated_kingwarrer(::NFMsg::Ident* kingwarrer);

  // .NFMsg.Ident hurter = 21;
  bool has_hurter() const;
  void clear_hurter();
  static const int kHurterFieldNumber = 21;
  private:
  const ::NFMsg::Ident& _internal_hurter() const;
  public:
  const ::NFMsg::Ident& hurter() const;
  ::NFMsg::Ident* release_hurter();
  ::NFMsg::Ident* mutable_hurter();
  void set_allocated_hurter(::NFMsg::Ident* hurter);

  // int32 kingwar_time = 10;
  void clear_kingwar_time();
  static const int kKingwarTimeFieldNumber = 10;
  ::google::protobuf::int32 kingwar_time() const;
  void set_kingwar_time(::google::protobuf::int32 value);

  // int32 hurting_time = 20;
  void clear_hurting_time();
  static const int kHurtingTimeFieldNumber = 20;
  ::google::protobuf::int32 hurting_time() const;
  void set_hurting_time(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:NFMsg.BigMapGridBaseInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::NFMsg::GridClanBaseInfo* guild_info_;
  ::NFMsg::Ident* kingwarrer_;
  ::NFMsg::Ident* hurter_;
  ::google::protobuf::int32 kingwar_time_;
  ::google::protobuf::int32 hurting_time_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_NFMsgExtra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LIBPROTOC_EXPORT BigMapLeaveMsg : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NFMsg.BigMapLeaveMsg) */ {
 public:
  BigMapLeaveMsg();
  virtual ~BigMapLeaveMsg();

  BigMapLeaveMsg(const BigMapLeaveMsg& from);

  inline BigMapLeaveMsg& operator=(const BigMapLeaveMsg& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BigMapLeaveMsg(BigMapLeaveMsg&& from) noexcept
    : BigMapLeaveMsg() {
    *this = ::std::move(from);
  }

  inline BigMapLeaveMsg& operator=(BigMapLeaveMsg&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const BigMapLeaveMsg& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BigMapLeaveMsg* internal_default_instance() {
    return reinterpret_cast<const BigMapLeaveMsg*>(
               &_BigMapLeaveMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(BigMapLeaveMsg* other);
  friend void swap(BigMapLeaveMsg& a, BigMapLeaveMsg& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BigMapLeaveMsg* New() const final {
    return CreateMaybeMessage<BigMapLeaveMsg>(NULL);
  }

  BigMapLeaveMsg* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BigMapLeaveMsg>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BigMapLeaveMsg& from);
  void MergeFrom(const BigMapLeaveMsg& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BigMapLeaveMsg* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes owner_name = 2;
  void clear_owner_name();
  static const int kOwnerNameFieldNumber = 2;
  const ::std::string& owner_name() const;
  void set_owner_name(const ::std::string& value);
  #if LANG_CXX11
  void set_owner_name(::std::string&& value);
  #endif
  void set_owner_name(const char* value);
  void set_owner_name(const void* value, size_t size);
  ::std::string* mutable_owner_name();
  ::std::string* release_owner_name();
  void set_allocated_owner_name(::std::string* owner_name);

  // bytes msg_data = 3;
  void clear_msg_data();
  static const int kMsgDataFieldNumber = 3;
  const ::std::string& msg_data() const;
  void set_msg_data(const ::std::string& value);
  #if LANG_CXX11
  void set_msg_data(::std::string&& value);
  #endif
  void set_msg_data(const char* value);
  void set_msg_data(const void* value, size_t size);
  ::std::string* mutable_msg_data();
  ::std::string* release_msg_data();
  void set_allocated_msg_data(::std::string* msg_data);

  // .NFMsg.Ident owner = 1;
  bool has_owner() const;
  void clear_owner();
  static const int kOwnerFieldNumber = 1;
  private:
  const ::NFMsg::Ident& _internal_owner() const;
  public:
  const ::NFMsg::Ident& owner() const;
  ::NFMsg::Ident* release_owner();
  ::NFMsg::Ident* mutable_owner();
  void set_allocated_owner(::NFMsg::Ident* owner);

  // int32 msg_time = 4;
  void clear_msg_time();
  static const int kMsgTimeFieldNumber = 4;
  ::google::protobuf::int32 msg_time() const;
  void set_msg_time(::google::protobuf::int32 value);

  // int32 owner_level = 5;
  void clear_owner_level();
  static const int kOwnerLevelFieldNumber = 5;
  ::google::protobuf::int32 owner_level() const;
  void set_owner_level(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:NFMsg.BigMapLeaveMsg)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr owner_name_;
  ::google::protobuf::internal::ArenaStringPtr msg_data_;
  ::NFMsg::Ident* owner_;
  ::google::protobuf::int32 msg_time_;
  ::google::protobuf::int32 owner_level_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_NFMsgExtra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LIBPROTOC_EXPORT BigMapWarHistory : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NFMsg.BigMapWarHistory) */ {
 public:
  BigMapWarHistory();
  virtual ~BigMapWarHistory();

  BigMapWarHistory(const BigMapWarHistory& from);

  inline BigMapWarHistory& operator=(const BigMapWarHistory& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BigMapWarHistory(BigMapWarHistory&& from) noexcept
    : BigMapWarHistory() {
    *this = ::std::move(from);
  }

  inline BigMapWarHistory& operator=(BigMapWarHistory&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const BigMapWarHistory& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BigMapWarHistory* internal_default_instance() {
    return reinterpret_cast<const BigMapWarHistory*>(
               &_BigMapWarHistory_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(BigMapWarHistory* other);
  friend void swap(BigMapWarHistory& a, BigMapWarHistory& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BigMapWarHistory* New() const final {
    return CreateMaybeMessage<BigMapWarHistory>(NULL);
  }

  BigMapWarHistory* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BigMapWarHistory>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BigMapWarHistory& from);
  void MergeFrom(const BigMapWarHistory& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BigMapWarHistory* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .NFMsg.GridClanBaseInfo red_info = 1;
  bool has_red_info() const;
  void clear_red_info();
  static const int kRedInfoFieldNumber = 1;
  private:
  const ::NFMsg::GridClanBaseInfo& _internal_red_info() const;
  public:
  const ::NFMsg::GridClanBaseInfo& red_info() const;
  ::NFMsg::GridClanBaseInfo* release_red_info();
  ::NFMsg::GridClanBaseInfo* mutable_red_info();
  void set_allocated_red_info(::NFMsg::GridClanBaseInfo* red_info);

  // .NFMsg.GridClanBaseInfo blue_info = 2;
  bool has_blue_info() const;
  void clear_blue_info();
  static const int kBlueInfoFieldNumber = 2;
  private:
  const ::NFMsg::GridClanBaseInfo& _internal_blue_info() const;
  public:
  const ::NFMsg::GridClanBaseInfo& blue_info() const;
  ::NFMsg::GridClanBaseInfo* release_blue_info();
  ::NFMsg::GridClanBaseInfo* mutable_blue_info();
  void set_allocated_blue_info(::NFMsg::GridClanBaseInfo* blue_info);

  // .NFMsg.Ident winner_id = 10;
  bool has_winner_id() const;
  void clear_winner_id();
  static const int kWinnerIdFieldNumber = 10;
  private:
  const ::NFMsg::Ident& _internal_winner_id() const;
  public:
  const ::NFMsg::Ident& winner_id() const;
  ::NFMsg::Ident* release_winner_id();
  ::NFMsg::Ident* mutable_winner_id();
  void set_allocated_winner_id(::NFMsg::Ident* winner_id);

  // int32 war_time = 11;
  void clear_war_time();
  static const int kWarTimeFieldNumber = 11;
  ::google::protobuf::int32 war_time() const;
  void set_war_time(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:NFMsg.BigMapWarHistory)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::NFMsg::GridClanBaseInfo* red_info_;
  ::NFMsg::GridClanBaseInfo* blue_info_;
  ::NFMsg::Ident* winner_id_;
  ::google::protobuf::int32 war_time_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_NFMsgExtra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LIBPROTOC_EXPORT BigMapGridDetailInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NFMsg.BigMapGridDetailInfo) */ {
 public:
  BigMapGridDetailInfo();
  virtual ~BigMapGridDetailInfo();

  BigMapGridDetailInfo(const BigMapGridDetailInfo& from);

  inline BigMapGridDetailInfo& operator=(const BigMapGridDetailInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BigMapGridDetailInfo(BigMapGridDetailInfo&& from) noexcept
    : BigMapGridDetailInfo() {
    *this = ::std::move(from);
  }

  inline BigMapGridDetailInfo& operator=(BigMapGridDetailInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const BigMapGridDetailInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BigMapGridDetailInfo* internal_default_instance() {
    return reinterpret_cast<const BigMapGridDetailInfo*>(
               &_BigMapGridDetailInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(BigMapGridDetailInfo* other);
  friend void swap(BigMapGridDetailInfo& a, BigMapGridDetailInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BigMapGridDetailInfo* New() const final {
    return CreateMaybeMessage<BigMapGridDetailInfo>(NULL);
  }

  BigMapGridDetailInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BigMapGridDetailInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BigMapGridDetailInfo& from);
  void MergeFrom(const BigMapGridDetailInfo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BigMapGridDetailInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .NFMsg.GridClanBaseInfo stay_guid_list = 2;
  int stay_guid_list_size() const;
  void clear_stay_guid_list();
  static const int kStayGuidListFieldNumber = 2;
  ::NFMsg::GridClanBaseInfo* mutable_stay_guid_list(int index);
  ::google::protobuf::RepeatedPtrField< ::NFMsg::GridClanBaseInfo >*
      mutable_stay_guid_list();
  const ::NFMsg::GridClanBaseInfo& stay_guid_list(int index) const;
  ::NFMsg::GridClanBaseInfo* add_stay_guid_list();
  const ::google::protobuf::RepeatedPtrField< ::NFMsg::GridClanBaseInfo >&
      stay_guid_list() const;

  // repeated .NFMsg.BigMapLeaveMsg leave_msg = 3;
  int leave_msg_size() const;
  void clear_leave_msg();
  static const int kLeaveMsgFieldNumber = 3;
  ::NFMsg::BigMapLeaveMsg* mutable_leave_msg(int index);
  ::google::protobuf::RepeatedPtrField< ::NFMsg::BigMapLeaveMsg >*
      mutable_leave_msg();
  const ::NFMsg::BigMapLeaveMsg& leave_msg(int index) const;
  ::NFMsg::BigMapLeaveMsg* add_leave_msg();
  const ::google::protobuf::RepeatedPtrField< ::NFMsg::BigMapLeaveMsg >&
      leave_msg() const;

  // repeated .NFMsg.BigMapWarHistory war_history = 4;
  int war_history_size() const;
  void clear_war_history();
  static const int kWarHistoryFieldNumber = 4;
  ::NFMsg::BigMapWarHistory* mutable_war_history(int index);
  ::google::protobuf::RepeatedPtrField< ::NFMsg::BigMapWarHistory >*
      mutable_war_history();
  const ::NFMsg::BigMapWarHistory& war_history(int index) const;
  ::NFMsg::BigMapWarHistory* add_war_history();
  const ::google::protobuf::RepeatedPtrField< ::NFMsg::BigMapWarHistory >&
      war_history() const;

  // .NFMsg.BigMapGridBaseInfo grid_base_info = 1;
  bool has_grid_base_info() const;
  void clear_grid_base_info();
  static const int kGridBaseInfoFieldNumber = 1;
  private:
  const ::NFMsg::BigMapGridBaseInfo& _internal_grid_base_info() const;
  public:
  const ::NFMsg::BigMapGridBaseInfo& grid_base_info() const;
  ::NFMsg::BigMapGridBaseInfo* release_grid_base_info();
  ::NFMsg::BigMapGridBaseInfo* mutable_grid_base_info();
  void set_allocated_grid_base_info(::NFMsg::BigMapGridBaseInfo* grid_base_info);

  // @@protoc_insertion_point(class_scope:NFMsg.BigMapGridDetailInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::NFMsg::GridClanBaseInfo > stay_guid_list_;
  ::google::protobuf::RepeatedPtrField< ::NFMsg::BigMapLeaveMsg > leave_msg_;
  ::google::protobuf::RepeatedPtrField< ::NFMsg::BigMapWarHistory > war_history_;
  ::NFMsg::BigMapGridBaseInfo* grid_base_info_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_NFMsgExtra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LIBPROTOC_EXPORT AckBigMapGridInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NFMsg.AckBigMapGridInfo) */ {
 public:
  AckBigMapGridInfo();
  virtual ~AckBigMapGridInfo();

  AckBigMapGridInfo(const AckBigMapGridInfo& from);

  inline AckBigMapGridInfo& operator=(const AckBigMapGridInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AckBigMapGridInfo(AckBigMapGridInfo&& from) noexcept
    : AckBigMapGridInfo() {
    *this = ::std::move(from);
  }

  inline AckBigMapGridInfo& operator=(AckBigMapGridInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AckBigMapGridInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AckBigMapGridInfo* internal_default_instance() {
    return reinterpret_cast<const AckBigMapGridInfo*>(
               &_AckBigMapGridInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(AckBigMapGridInfo* other);
  friend void swap(AckBigMapGridInfo& a, AckBigMapGridInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AckBigMapGridInfo* New() const final {
    return CreateMaybeMessage<AckBigMapGridInfo>(NULL);
  }

  AckBigMapGridInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AckBigMapGridInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AckBigMapGridInfo& from);
  void MergeFrom(const AckBigMapGridInfo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AckBigMapGridInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .NFMsg.BigMapGridDetailInfo map_data = 1;
  int map_data_size() const;
  void clear_map_data();
  static const int kMapDataFieldNumber = 1;
  ::NFMsg::BigMapGridDetailInfo* mutable_map_data(int index);
  ::google::protobuf::RepeatedPtrField< ::NFMsg::BigMapGridDetailInfo >*
      mutable_map_data();
  const ::NFMsg::BigMapGridDetailInfo& map_data(int index) const;
  ::NFMsg::BigMapGridDetailInfo* add_map_data();
  const ::google::protobuf::RepeatedPtrField< ::NFMsg::BigMapGridDetailInfo >&
      map_data() const;

  // @@protoc_insertion_point(class_scope:NFMsg.AckBigMapGridInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::NFMsg::BigMapGridDetailInfo > map_data_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_NFMsgExtra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LIBPROTOC_EXPORT ReqBigMapInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NFMsg.ReqBigMapInfo) */ {
 public:
  ReqBigMapInfo();
  virtual ~ReqBigMapInfo();

  ReqBigMapInfo(const ReqBigMapInfo& from);

  inline ReqBigMapInfo& operator=(const ReqBigMapInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ReqBigMapInfo(ReqBigMapInfo&& from) noexcept
    : ReqBigMapInfo() {
    *this = ::std::move(from);
  }

  inline ReqBigMapInfo& operator=(ReqBigMapInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqBigMapInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReqBigMapInfo* internal_default_instance() {
    return reinterpret_cast<const ReqBigMapInfo*>(
               &_ReqBigMapInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(ReqBigMapInfo* other);
  friend void swap(ReqBigMapInfo& a, ReqBigMapInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ReqBigMapInfo* New() const final {
    return CreateMaybeMessage<ReqBigMapInfo>(NULL);
  }

  ReqBigMapInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ReqBigMapInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ReqBigMapInfo& from);
  void MergeFrom(const ReqBigMapInfo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReqBigMapInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:NFMsg.ReqBigMapInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_NFMsgExtra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LIBPROTOC_EXPORT AckBigMapInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NFMsg.AckBigMapInfo) */ {
 public:
  AckBigMapInfo();
  virtual ~AckBigMapInfo();

  AckBigMapInfo(const AckBigMapInfo& from);

  inline AckBigMapInfo& operator=(const AckBigMapInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AckBigMapInfo(AckBigMapInfo&& from) noexcept
    : AckBigMapInfo() {
    *this = ::std::move(from);
  }

  inline AckBigMapInfo& operator=(AckBigMapInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AckBigMapInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AckBigMapInfo* internal_default_instance() {
    return reinterpret_cast<const AckBigMapInfo*>(
               &_AckBigMapInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(AckBigMapInfo* other);
  friend void swap(AckBigMapInfo& a, AckBigMapInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AckBigMapInfo* New() const final {
    return CreateMaybeMessage<AckBigMapInfo>(NULL);
  }

  AckBigMapInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AckBigMapInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AckBigMapInfo& from);
  void MergeFrom(const AckBigMapInfo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AckBigMapInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .NFMsg.BigMapGridBaseInfo grid_base_info = 1;
  int grid_base_info_size() const;
  void clear_grid_base_info();
  static const int kGridBaseInfoFieldNumber = 1;
  ::NFMsg::BigMapGridBaseInfo* mutable_grid_base_info(int index);
  ::google::protobuf::RepeatedPtrField< ::NFMsg::BigMapGridBaseInfo >*
      mutable_grid_base_info();
  const ::NFMsg::BigMapGridBaseInfo& grid_base_info(int index) const;
  ::NFMsg::BigMapGridBaseInfo* add_grid_base_info();
  const ::google::protobuf::RepeatedPtrField< ::NFMsg::BigMapGridBaseInfo >&
      grid_base_info() const;

  // @@protoc_insertion_point(class_scope:NFMsg.AckBigMapInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::NFMsg::BigMapGridBaseInfo > grid_base_info_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_NFMsgExtra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LIBPROTOC_EXPORT ReqHoldMapGrid : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NFMsg.ReqHoldMapGrid) */ {
 public:
  ReqHoldMapGrid();
  virtual ~ReqHoldMapGrid();

  ReqHoldMapGrid(const ReqHoldMapGrid& from);

  inline ReqHoldMapGrid& operator=(const ReqHoldMapGrid& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ReqHoldMapGrid(ReqHoldMapGrid&& from) noexcept
    : ReqHoldMapGrid() {
    *this = ::std::move(from);
  }

  inline ReqHoldMapGrid& operator=(ReqHoldMapGrid&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqHoldMapGrid& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReqHoldMapGrid* internal_default_instance() {
    return reinterpret_cast<const ReqHoldMapGrid*>(
               &_ReqHoldMapGrid_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(ReqHoldMapGrid* other);
  friend void swap(ReqHoldMapGrid& a, ReqHoldMapGrid& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ReqHoldMapGrid* New() const final {
    return CreateMaybeMessage<ReqHoldMapGrid>(NULL);
  }

  ReqHoldMapGrid* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ReqHoldMapGrid>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ReqHoldMapGrid& from);
  void MergeFrom(const ReqHoldMapGrid& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReqHoldMapGrid* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes map_title_id = 1;
  void clear_map_title_id();
  static const int kMapTitleIdFieldNumber = 1;
  const ::std::string& map_title_id() const;
  void set_map_title_id(const ::std::string& value);
  #if LANG_CXX11
  void set_map_title_id(::std::string&& value);
  #endif
  void set_map_title_id(const char* value);
  void set_map_title_id(const void* value, size_t size);
  ::std::string* mutable_map_title_id();
  ::std::string* release_map_title_id();
  void set_allocated_map_title_id(::std::string* map_title_id);

  // .NFMsg.Ident guild_id = 2;
  bool has_guild_id() const;
  void clear_guild_id();
  static const int kGuildIdFieldNumber = 2;
  private:
  const ::NFMsg::Ident& _internal_guild_id() const;
  public:
  const ::NFMsg::Ident& guild_id() const;
  ::NFMsg::Ident* release_guild_id();
  ::NFMsg::Ident* mutable_guild_id();
  void set_allocated_guild_id(::NFMsg::Ident* guild_id);

  // @@protoc_insertion_point(class_scope:NFMsg.ReqHoldMapGrid)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr map_title_id_;
  ::NFMsg::Ident* guild_id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_NFMsgExtra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LIBPROTOC_EXPORT AckHoldMapGrid : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NFMsg.AckHoldMapGrid) */ {
 public:
  AckHoldMapGrid();
  virtual ~AckHoldMapGrid();

  AckHoldMapGrid(const AckHoldMapGrid& from);

  inline AckHoldMapGrid& operator=(const AckHoldMapGrid& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AckHoldMapGrid(AckHoldMapGrid&& from) noexcept
    : AckHoldMapGrid() {
    *this = ::std::move(from);
  }

  inline AckHoldMapGrid& operator=(AckHoldMapGrid&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AckHoldMapGrid& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AckHoldMapGrid* internal_default_instance() {
    return reinterpret_cast<const AckHoldMapGrid*>(
               &_AckHoldMapGrid_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(AckHoldMapGrid* other);
  friend void swap(AckHoldMapGrid& a, AckHoldMapGrid& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AckHoldMapGrid* New() const final {
    return CreateMaybeMessage<AckHoldMapGrid>(NULL);
  }

  AckHoldMapGrid* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AckHoldMapGrid>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AckHoldMapGrid& from);
  void MergeFrom(const AckHoldMapGrid& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AckHoldMapGrid* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:NFMsg.AckHoldMapGrid)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_NFMsgExtra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LIBPROTOC_EXPORT ReqLeaveMapMsg : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NFMsg.ReqLeaveMapMsg) */ {
 public:
  ReqLeaveMapMsg();
  virtual ~ReqLeaveMapMsg();

  ReqLeaveMapMsg(const ReqLeaveMapMsg& from);

  inline ReqLeaveMapMsg& operator=(const ReqLeaveMapMsg& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ReqLeaveMapMsg(ReqLeaveMapMsg&& from) noexcept
    : ReqLeaveMapMsg() {
    *this = ::std::move(from);
  }

  inline ReqLeaveMapMsg& operator=(ReqLeaveMapMsg&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqLeaveMapMsg& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReqLeaveMapMsg* internal_default_instance() {
    return reinterpret_cast<const ReqLeaveMapMsg*>(
               &_ReqLeaveMapMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(ReqLeaveMapMsg* other);
  friend void swap(ReqLeaveMapMsg& a, ReqLeaveMapMsg& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ReqLeaveMapMsg* New() const final {
    return CreateMaybeMessage<ReqLeaveMapMsg>(NULL);
  }

  ReqLeaveMapMsg* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ReqLeaveMapMsg>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ReqLeaveMapMsg& from);
  void MergeFrom(const ReqLeaveMapMsg& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReqLeaveMapMsg* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes map_title_id = 1;
  void clear_map_title_id();
  static const int kMapTitleIdFieldNumber = 1;
  const ::std::string& map_title_id() const;
  void set_map_title_id(const ::std::string& value);
  #if LANG_CXX11
  void set_map_title_id(::std::string&& value);
  #endif
  void set_map_title_id(const char* value);
  void set_map_title_id(const void* value, size_t size);
  ::std::string* mutable_map_title_id();
  ::std::string* release_map_title_id();
  void set_allocated_map_title_id(::std::string* map_title_id);

  // .NFMsg.BigMapLeaveMsg leave_msg = 2;
  bool has_leave_msg() const;
  void clear_leave_msg();
  static const int kLeaveMsgFieldNumber = 2;
  private:
  const ::NFMsg::BigMapLeaveMsg& _internal_leave_msg() const;
  public:
  const ::NFMsg::BigMapLeaveMsg& leave_msg() const;
  ::NFMsg::BigMapLeaveMsg* release_leave_msg();
  ::NFMsg::BigMapLeaveMsg* mutable_leave_msg();
  void set_allocated_leave_msg(::NFMsg::BigMapLeaveMsg* leave_msg);

  // @@protoc_insertion_point(class_scope:NFMsg.ReqLeaveMapMsg)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr map_title_id_;
  ::NFMsg::BigMapLeaveMsg* leave_msg_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_NFMsgExtra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LIBPROTOC_EXPORT AckLeaveMapMsg : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NFMsg.AckLeaveMapMsg) */ {
 public:
  AckLeaveMapMsg();
  virtual ~AckLeaveMapMsg();

  AckLeaveMapMsg(const AckLeaveMapMsg& from);

  inline AckLeaveMapMsg& operator=(const AckLeaveMapMsg& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AckLeaveMapMsg(AckLeaveMapMsg&& from) noexcept
    : AckLeaveMapMsg() {
    *this = ::std::move(from);
  }

  inline AckLeaveMapMsg& operator=(AckLeaveMapMsg&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AckLeaveMapMsg& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AckLeaveMapMsg* internal_default_instance() {
    return reinterpret_cast<const AckLeaveMapMsg*>(
               &_AckLeaveMapMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(AckLeaveMapMsg* other);
  friend void swap(AckLeaveMapMsg& a, AckLeaveMapMsg& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AckLeaveMapMsg* New() const final {
    return CreateMaybeMessage<AckLeaveMapMsg>(NULL);
  }

  AckLeaveMapMsg* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AckLeaveMapMsg>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AckLeaveMapMsg& from);
  void MergeFrom(const AckLeaveMapMsg& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AckLeaveMapMsg* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:NFMsg.AckLeaveMapMsg)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_NFMsgExtra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LIBPROTOC_EXPORT ReqGetMapAward : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NFMsg.ReqGetMapAward) */ {
 public:
  ReqGetMapAward();
  virtual ~ReqGetMapAward();

  ReqGetMapAward(const ReqGetMapAward& from);

  inline ReqGetMapAward& operator=(const ReqGetMapAward& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ReqGetMapAward(ReqGetMapAward&& from) noexcept
    : ReqGetMapAward() {
    *this = ::std::move(from);
  }

  inline ReqGetMapAward& operator=(ReqGetMapAward&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqGetMapAward& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReqGetMapAward* internal_default_instance() {
    return reinterpret_cast<const ReqGetMapAward*>(
               &_ReqGetMapAward_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void Swap(ReqGetMapAward* other);
  friend void swap(ReqGetMapAward& a, ReqGetMapAward& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ReqGetMapAward* New() const final {
    return CreateMaybeMessage<ReqGetMapAward>(NULL);
  }

  ReqGetMapAward* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ReqGetMapAward>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ReqGetMapAward& from);
  void MergeFrom(const ReqGetMapAward& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReqGetMapAward* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes map_title_id = 1;
  void clear_map_title_id();
  static const int kMapTitleIdFieldNumber = 1;
  const ::std::string& map_title_id() const;
  void set_map_title_id(const ::std::string& value);
  #if LANG_CXX11
  void set_map_title_id(::std::string&& value);
  #endif
  void set_map_title_id(const char* value);
  void set_map_title_id(const void* value, size_t size);
  ::std::string* mutable_map_title_id();
  ::std::string* release_map_title_id();
  void set_allocated_map_title_id(::std::string* map_title_id);

  // @@protoc_insertion_point(class_scope:NFMsg.ReqGetMapAward)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr map_title_id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_NFMsgExtra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LIBPROTOC_EXPORT AckGetMapAward : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NFMsg.AckGetMapAward) */ {
 public:
  AckGetMapAward();
  virtual ~AckGetMapAward();

  AckGetMapAward(const AckGetMapAward& from);

  inline AckGetMapAward& operator=(const AckGetMapAward& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AckGetMapAward(AckGetMapAward&& from) noexcept
    : AckGetMapAward() {
    *this = ::std::move(from);
  }

  inline AckGetMapAward& operator=(AckGetMapAward&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AckGetMapAward& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AckGetMapAward* internal_default_instance() {
    return reinterpret_cast<const AckGetMapAward*>(
               &_AckGetMapAward_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  void Swap(AckGetMapAward* other);
  friend void swap(AckGetMapAward& a, AckGetMapAward& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AckGetMapAward* New() const final {
    return CreateMaybeMessage<AckGetMapAward>(NULL);
  }

  AckGetMapAward* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AckGetMapAward>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AckGetMapAward& from);
  void MergeFrom(const AckGetMapAward& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AckGetMapAward* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:NFMsg.AckGetMapAward)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_NFMsgExtra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LIBPROTOC_EXPORT ReqMapHunting : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NFMsg.ReqMapHunting) */ {
 public:
  ReqMapHunting();
  virtual ~ReqMapHunting();

  ReqMapHunting(const ReqMapHunting& from);

  inline ReqMapHunting& operator=(const ReqMapHunting& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ReqMapHunting(ReqMapHunting&& from) noexcept
    : ReqMapHunting() {
    *this = ::std::move(from);
  }

  inline ReqMapHunting& operator=(ReqMapHunting&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqMapHunting& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReqMapHunting* internal_default_instance() {
    return reinterpret_cast<const ReqMapHunting*>(
               &_ReqMapHunting_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  void Swap(ReqMapHunting* other);
  friend void swap(ReqMapHunting& a, ReqMapHunting& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ReqMapHunting* New() const final {
    return CreateMaybeMessage<ReqMapHunting>(NULL);
  }

  ReqMapHunting* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ReqMapHunting>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ReqMapHunting& from);
  void MergeFrom(const ReqMapHunting& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReqMapHunting* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes map_title_id = 1;
  void clear_map_title_id();
  static const int kMapTitleIdFieldNumber = 1;
  const ::std::string& map_title_id() const;
  void set_map_title_id(const ::std::string& value);
  #if LANG_CXX11
  void set_map_title_id(::std::string&& value);
  #endif
  void set_map_title_id(const char* value);
  void set_map_title_id(const void* value, size_t size);
  ::std::string* mutable_map_title_id();
  ::std::string* release_map_title_id();
  void set_allocated_map_title_id(::std::string* map_title_id);

  // @@protoc_insertion_point(class_scope:NFMsg.ReqMapHunting)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr map_title_id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_NFMsgExtra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LIBPROTOC_EXPORT AckMapHunting : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NFMsg.AckMapHunting) */ {
 public:
  AckMapHunting();
  virtual ~AckMapHunting();

  AckMapHunting(const AckMapHunting& from);

  inline AckMapHunting& operator=(const AckMapHunting& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AckMapHunting(AckMapHunting&& from) noexcept
    : AckMapHunting() {
    *this = ::std::move(from);
  }

  inline AckMapHunting& operator=(AckMapHunting&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AckMapHunting& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AckMapHunting* internal_default_instance() {
    return reinterpret_cast<const AckMapHunting*>(
               &_AckMapHunting_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  void Swap(AckMapHunting* other);
  friend void swap(AckMapHunting& a, AckMapHunting& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AckMapHunting* New() const final {
    return CreateMaybeMessage<AckMapHunting>(NULL);
  }

  AckMapHunting* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AckMapHunting>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AckMapHunting& from);
  void MergeFrom(const AckMapHunting& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AckMapHunting* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:NFMsg.AckMapHunting)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_NFMsgExtra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LIBPROTOC_EXPORT ReqMapKingWar : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NFMsg.ReqMapKingWar) */ {
 public:
  ReqMapKingWar();
  virtual ~ReqMapKingWar();

  ReqMapKingWar(const ReqMapKingWar& from);

  inline ReqMapKingWar& operator=(const ReqMapKingWar& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ReqMapKingWar(ReqMapKingWar&& from) noexcept
    : ReqMapKingWar() {
    *this = ::std::move(from);
  }

  inline ReqMapKingWar& operator=(ReqMapKingWar&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqMapKingWar& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReqMapKingWar* internal_default_instance() {
    return reinterpret_cast<const ReqMapKingWar*>(
               &_ReqMapKingWar_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  void Swap(ReqMapKingWar* other);
  friend void swap(ReqMapKingWar& a, ReqMapKingWar& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ReqMapKingWar* New() const final {
    return CreateMaybeMessage<ReqMapKingWar>(NULL);
  }

  ReqMapKingWar* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ReqMapKingWar>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ReqMapKingWar& from);
  void MergeFrom(const ReqMapKingWar& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReqMapKingWar* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes map_title = 1;
  void clear_map_title();
  static const int kMapTitleFieldNumber = 1;
  const ::std::string& map_title() const;
  void set_map_title(const ::std::string& value);
  #if LANG_CXX11
  void set_map_title(::std::string&& value);
  #endif
  void set_map_title(const char* value);
  void set_map_title(const void* value, size_t size);
  ::std::string* mutable_map_title();
  ::std::string* release_map_title();
  void set_allocated_map_title(::std::string* map_title);

  // @@protoc_insertion_point(class_scope:NFMsg.ReqMapKingWar)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr map_title_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_NFMsgExtra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LIBPROTOC_EXPORT AckMapKingWar : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NFMsg.AckMapKingWar) */ {
 public:
  AckMapKingWar();
  virtual ~AckMapKingWar();

  AckMapKingWar(const AckMapKingWar& from);

  inline AckMapKingWar& operator=(const AckMapKingWar& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AckMapKingWar(AckMapKingWar&& from) noexcept
    : AckMapKingWar() {
    *this = ::std::move(from);
  }

  inline AckMapKingWar& operator=(AckMapKingWar&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AckMapKingWar& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AckMapKingWar* internal_default_instance() {
    return reinterpret_cast<const AckMapKingWar*>(
               &_AckMapKingWar_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  void Swap(AckMapKingWar* other);
  friend void swap(AckMapKingWar& a, AckMapKingWar& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AckMapKingWar* New() const final {
    return CreateMaybeMessage<AckMapKingWar>(NULL);
  }

  AckMapKingWar* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AckMapKingWar>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AckMapKingWar& from);
  void MergeFrom(const AckMapKingWar& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AckMapKingWar* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes map_title = 1;
  void clear_map_title();
  static const int kMapTitleFieldNumber = 1;
  const ::std::string& map_title() const;
  void set_map_title(const ::std::string& value);
  #if LANG_CXX11
  void set_map_title(::std::string&& value);
  #endif
  void set_map_title(const char* value);
  void set_map_title(const void* value, size_t size);
  ::std::string* mutable_map_title();
  ::std::string* release_map_title();
  void set_allocated_map_title(::std::string* map_title);

  // @@protoc_insertion_point(class_scope:NFMsg.AckMapKingWar)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr map_title_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_NFMsgExtra_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ReqAIOnwer

// .NFMsg.Ident ai_id = 1;
inline bool ReqAIOnwer::has_ai_id() const {
  return this != internal_default_instance() && ai_id_ != NULL;
}
inline const ::NFMsg::Ident& ReqAIOnwer::_internal_ai_id() const {
  return *ai_id_;
}
inline const ::NFMsg::Ident& ReqAIOnwer::ai_id() const {
  const ::NFMsg::Ident* p = ai_id_;
  // @@protoc_insertion_point(field_get:NFMsg.ReqAIOnwer.ai_id)
  return p != NULL ? *p : *reinterpret_cast<const ::NFMsg::Ident*>(
      &::NFMsg::_Ident_default_instance_);
}
inline ::NFMsg::Ident* ReqAIOnwer::release_ai_id() {
  // @@protoc_insertion_point(field_release:NFMsg.ReqAIOnwer.ai_id)
  
  ::NFMsg::Ident* temp = ai_id_;
  ai_id_ = NULL;
  return temp;
}
inline ::NFMsg::Ident* ReqAIOnwer::mutable_ai_id() {
  
  if (ai_id_ == NULL) {
    auto* p = CreateMaybeMessage<::NFMsg::Ident>(GetArenaNoVirtual());
    ai_id_ = p;
  }
  // @@protoc_insertion_point(field_mutable:NFMsg.ReqAIOnwer.ai_id)
  return ai_id_;
}
inline void ReqAIOnwer::set_allocated_ai_id(::NFMsg::Ident* ai_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(ai_id_);
  }
  if (ai_id) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      ai_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, ai_id, submessage_arena);
    }
    
  } else {
    
  }
  ai_id_ = ai_id;
  // @@protoc_insertion_point(field_set_allocated:NFMsg.ReqAIOnwer.ai_id)
}

// -------------------------------------------------------------------

// GridClanBaseInfo

// .NFMsg.Ident id = 1;
inline bool GridClanBaseInfo::has_id() const {
  return this != internal_default_instance() && id_ != NULL;
}
inline const ::NFMsg::Ident& GridClanBaseInfo::_internal_id() const {
  return *id_;
}
inline const ::NFMsg::Ident& GridClanBaseInfo::id() const {
  const ::NFMsg::Ident* p = id_;
  // @@protoc_insertion_point(field_get:NFMsg.GridClanBaseInfo.id)
  return p != NULL ? *p : *reinterpret_cast<const ::NFMsg::Ident*>(
      &::NFMsg::_Ident_default_instance_);
}
inline ::NFMsg::Ident* GridClanBaseInfo::release_id() {
  // @@protoc_insertion_point(field_release:NFMsg.GridClanBaseInfo.id)
  
  ::NFMsg::Ident* temp = id_;
  id_ = NULL;
  return temp;
}
inline ::NFMsg::Ident* GridClanBaseInfo::mutable_id() {
  
  if (id_ == NULL) {
    auto* p = CreateMaybeMessage<::NFMsg::Ident>(GetArenaNoVirtual());
    id_ = p;
  }
  // @@protoc_insertion_point(field_mutable:NFMsg.GridClanBaseInfo.id)
  return id_;
}
inline void GridClanBaseInfo::set_allocated_id(::NFMsg::Ident* id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(id_);
  }
  if (id) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, id, submessage_arena);
    }
    
  } else {
    
  }
  id_ = id;
  // @@protoc_insertion_point(field_set_allocated:NFMsg.GridClanBaseInfo.id)
}

// int32 level = 2;
inline void GridClanBaseInfo::clear_level() {
  level_ = 0;
}
inline ::google::protobuf::int32 GridClanBaseInfo::level() const {
  // @@protoc_insertion_point(field_get:NFMsg.GridClanBaseInfo.level)
  return level_;
}
inline void GridClanBaseInfo::set_level(::google::protobuf::int32 value) {
  
  level_ = value;
  // @@protoc_insertion_point(field_set:NFMsg.GridClanBaseInfo.level)
}

// int32 count = 3;
inline void GridClanBaseInfo::clear_count() {
  count_ = 0;
}
inline ::google::protobuf::int32 GridClanBaseInfo::count() const {
  // @@protoc_insertion_point(field_get:NFMsg.GridClanBaseInfo.count)
  return count_;
}
inline void GridClanBaseInfo::set_count(::google::protobuf::int32 value) {
  
  count_ = value;
  // @@protoc_insertion_point(field_set:NFMsg.GridClanBaseInfo.count)
}

// int32 resource = 4;
inline void GridClanBaseInfo::clear_resource() {
  resource_ = 0;
}
inline ::google::protobuf::int32 GridClanBaseInfo::resource() const {
  // @@protoc_insertion_point(field_get:NFMsg.GridClanBaseInfo.resource)
  return resource_;
}
inline void GridClanBaseInfo::set_resource(::google::protobuf::int32 value) {
  
  resource_ = value;
  // @@protoc_insertion_point(field_set:NFMsg.GridClanBaseInfo.resource)
}

// bytes icon = 5;
inline void GridClanBaseInfo::clear_icon() {
  icon_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GridClanBaseInfo::icon() const {
  // @@protoc_insertion_point(field_get:NFMsg.GridClanBaseInfo.icon)
  return icon_.GetNoArena();
}
inline void GridClanBaseInfo::set_icon(const ::std::string& value) {
  
  icon_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:NFMsg.GridClanBaseInfo.icon)
}
#if LANG_CXX11
inline void GridClanBaseInfo::set_icon(::std::string&& value) {
  
  icon_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:NFMsg.GridClanBaseInfo.icon)
}
#endif
inline void GridClanBaseInfo::set_icon(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  icon_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:NFMsg.GridClanBaseInfo.icon)
}
inline void GridClanBaseInfo::set_icon(const void* value, size_t size) {
  
  icon_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:NFMsg.GridClanBaseInfo.icon)
}
inline ::std::string* GridClanBaseInfo::mutable_icon() {
  
  // @@protoc_insertion_point(field_mutable:NFMsg.GridClanBaseInfo.icon)
  return icon_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GridClanBaseInfo::release_icon() {
  // @@protoc_insertion_point(field_release:NFMsg.GridClanBaseInfo.icon)
  
  return icon_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GridClanBaseInfo::set_allocated_icon(::std::string* icon) {
  if (icon != NULL) {
    
  } else {
    
  }
  icon_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), icon);
  // @@protoc_insertion_point(field_set_allocated:NFMsg.GridClanBaseInfo.icon)
}

// -------------------------------------------------------------------

// ReqBigMapGridInfo

// repeated bytes map_title_id = 1;
inline int ReqBigMapGridInfo::map_title_id_size() const {
  return map_title_id_.size();
}
inline void ReqBigMapGridInfo::clear_map_title_id() {
  map_title_id_.Clear();
}
inline const ::std::string& ReqBigMapGridInfo::map_title_id(int index) const {
  // @@protoc_insertion_point(field_get:NFMsg.ReqBigMapGridInfo.map_title_id)
  return map_title_id_.Get(index);
}
inline ::std::string* ReqBigMapGridInfo::mutable_map_title_id(int index) {
  // @@protoc_insertion_point(field_mutable:NFMsg.ReqBigMapGridInfo.map_title_id)
  return map_title_id_.Mutable(index);
}
inline void ReqBigMapGridInfo::set_map_title_id(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:NFMsg.ReqBigMapGridInfo.map_title_id)
  map_title_id_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void ReqBigMapGridInfo::set_map_title_id(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:NFMsg.ReqBigMapGridInfo.map_title_id)
  map_title_id_.Mutable(index)->assign(std::move(value));
}
#endif
inline void ReqBigMapGridInfo::set_map_title_id(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  map_title_id_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:NFMsg.ReqBigMapGridInfo.map_title_id)
}
inline void ReqBigMapGridInfo::set_map_title_id(int index, const void* value, size_t size) {
  map_title_id_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:NFMsg.ReqBigMapGridInfo.map_title_id)
}
inline ::std::string* ReqBigMapGridInfo::add_map_title_id() {
  // @@protoc_insertion_point(field_add_mutable:NFMsg.ReqBigMapGridInfo.map_title_id)
  return map_title_id_.Add();
}
inline void ReqBigMapGridInfo::add_map_title_id(const ::std::string& value) {
  map_title_id_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:NFMsg.ReqBigMapGridInfo.map_title_id)
}
#if LANG_CXX11
inline void ReqBigMapGridInfo::add_map_title_id(::std::string&& value) {
  map_title_id_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:NFMsg.ReqBigMapGridInfo.map_title_id)
}
#endif
inline void ReqBigMapGridInfo::add_map_title_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  map_title_id_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:NFMsg.ReqBigMapGridInfo.map_title_id)
}
inline void ReqBigMapGridInfo::add_map_title_id(const void* value, size_t size) {
  map_title_id_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:NFMsg.ReqBigMapGridInfo.map_title_id)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ReqBigMapGridInfo::map_title_id() const {
  // @@protoc_insertion_point(field_list:NFMsg.ReqBigMapGridInfo.map_title_id)
  return map_title_id_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ReqBigMapGridInfo::mutable_map_title_id() {
  // @@protoc_insertion_point(field_mutable_list:NFMsg.ReqBigMapGridInfo.map_title_id)
  return &map_title_id_;
}

// -------------------------------------------------------------------

// BigMapGridBaseInfo

// bytes id = 1;
inline void BigMapGridBaseInfo::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& BigMapGridBaseInfo::id() const {
  // @@protoc_insertion_point(field_get:NFMsg.BigMapGridBaseInfo.id)
  return id_.GetNoArena();
}
inline void BigMapGridBaseInfo::set_id(const ::std::string& value) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:NFMsg.BigMapGridBaseInfo.id)
}
#if LANG_CXX11
inline void BigMapGridBaseInfo::set_id(::std::string&& value) {
  
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:NFMsg.BigMapGridBaseInfo.id)
}
#endif
inline void BigMapGridBaseInfo::set_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:NFMsg.BigMapGridBaseInfo.id)
}
inline void BigMapGridBaseInfo::set_id(const void* value, size_t size) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:NFMsg.BigMapGridBaseInfo.id)
}
inline ::std::string* BigMapGridBaseInfo::mutable_id() {
  
  // @@protoc_insertion_point(field_mutable:NFMsg.BigMapGridBaseInfo.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BigMapGridBaseInfo::release_id() {
  // @@protoc_insertion_point(field_release:NFMsg.BigMapGridBaseInfo.id)
  
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BigMapGridBaseInfo::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    
  } else {
    
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:NFMsg.BigMapGridBaseInfo.id)
}

// .NFMsg.GridClanBaseInfo guild_info = 2;
inline bool BigMapGridBaseInfo::has_guild_info() const {
  return this != internal_default_instance() && guild_info_ != NULL;
}
inline void BigMapGridBaseInfo::clear_guild_info() {
  if (GetArenaNoVirtual() == NULL && guild_info_ != NULL) {
    delete guild_info_;
  }
  guild_info_ = NULL;
}
inline const ::NFMsg::GridClanBaseInfo& BigMapGridBaseInfo::_internal_guild_info() const {
  return *guild_info_;
}
inline const ::NFMsg::GridClanBaseInfo& BigMapGridBaseInfo::guild_info() const {
  const ::NFMsg::GridClanBaseInfo* p = guild_info_;
  // @@protoc_insertion_point(field_get:NFMsg.BigMapGridBaseInfo.guild_info)
  return p != NULL ? *p : *reinterpret_cast<const ::NFMsg::GridClanBaseInfo*>(
      &::NFMsg::_GridClanBaseInfo_default_instance_);
}
inline ::NFMsg::GridClanBaseInfo* BigMapGridBaseInfo::release_guild_info() {
  // @@protoc_insertion_point(field_release:NFMsg.BigMapGridBaseInfo.guild_info)
  
  ::NFMsg::GridClanBaseInfo* temp = guild_info_;
  guild_info_ = NULL;
  return temp;
}
inline ::NFMsg::GridClanBaseInfo* BigMapGridBaseInfo::mutable_guild_info() {
  
  if (guild_info_ == NULL) {
    auto* p = CreateMaybeMessage<::NFMsg::GridClanBaseInfo>(GetArenaNoVirtual());
    guild_info_ = p;
  }
  // @@protoc_insertion_point(field_mutable:NFMsg.BigMapGridBaseInfo.guild_info)
  return guild_info_;
}
inline void BigMapGridBaseInfo::set_allocated_guild_info(::NFMsg::GridClanBaseInfo* guild_info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete guild_info_;
  }
  if (guild_info) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      guild_info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, guild_info, submessage_arena);
    }
    
  } else {
    
  }
  guild_info_ = guild_info;
  // @@protoc_insertion_point(field_set_allocated:NFMsg.BigMapGridBaseInfo.guild_info)
}

// int32 kingwar_time = 10;
inline void BigMapGridBaseInfo::clear_kingwar_time() {
  kingwar_time_ = 0;
}
inline ::google::protobuf::int32 BigMapGridBaseInfo::kingwar_time() const {
  // @@protoc_insertion_point(field_get:NFMsg.BigMapGridBaseInfo.kingwar_time)
  return kingwar_time_;
}
inline void BigMapGridBaseInfo::set_kingwar_time(::google::protobuf::int32 value) {
  
  kingwar_time_ = value;
  // @@protoc_insertion_point(field_set:NFMsg.BigMapGridBaseInfo.kingwar_time)
}

// .NFMsg.Ident kingwarrer = 11;
inline bool BigMapGridBaseInfo::has_kingwarrer() const {
  return this != internal_default_instance() && kingwarrer_ != NULL;
}
inline const ::NFMsg::Ident& BigMapGridBaseInfo::_internal_kingwarrer() const {
  return *kingwarrer_;
}
inline const ::NFMsg::Ident& BigMapGridBaseInfo::kingwarrer() const {
  const ::NFMsg::Ident* p = kingwarrer_;
  // @@protoc_insertion_point(field_get:NFMsg.BigMapGridBaseInfo.kingwarrer)
  return p != NULL ? *p : *reinterpret_cast<const ::NFMsg::Ident*>(
      &::NFMsg::_Ident_default_instance_);
}
inline ::NFMsg::Ident* BigMapGridBaseInfo::release_kingwarrer() {
  // @@protoc_insertion_point(field_release:NFMsg.BigMapGridBaseInfo.kingwarrer)
  
  ::NFMsg::Ident* temp = kingwarrer_;
  kingwarrer_ = NULL;
  return temp;
}
inline ::NFMsg::Ident* BigMapGridBaseInfo::mutable_kingwarrer() {
  
  if (kingwarrer_ == NULL) {
    auto* p = CreateMaybeMessage<::NFMsg::Ident>(GetArenaNoVirtual());
    kingwarrer_ = p;
  }
  // @@protoc_insertion_point(field_mutable:NFMsg.BigMapGridBaseInfo.kingwarrer)
  return kingwarrer_;
}
inline void BigMapGridBaseInfo::set_allocated_kingwarrer(::NFMsg::Ident* kingwarrer) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(kingwarrer_);
  }
  if (kingwarrer) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      kingwarrer = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, kingwarrer, submessage_arena);
    }
    
  } else {
    
  }
  kingwarrer_ = kingwarrer;
  // @@protoc_insertion_point(field_set_allocated:NFMsg.BigMapGridBaseInfo.kingwarrer)
}

// int32 hurting_time = 20;
inline void BigMapGridBaseInfo::clear_hurting_time() {
  hurting_time_ = 0;
}
inline ::google::protobuf::int32 BigMapGridBaseInfo::hurting_time() const {
  // @@protoc_insertion_point(field_get:NFMsg.BigMapGridBaseInfo.hurting_time)
  return hurting_time_;
}
inline void BigMapGridBaseInfo::set_hurting_time(::google::protobuf::int32 value) {
  
  hurting_time_ = value;
  // @@protoc_insertion_point(field_set:NFMsg.BigMapGridBaseInfo.hurting_time)
}

// .NFMsg.Ident hurter = 21;
inline bool BigMapGridBaseInfo::has_hurter() const {
  return this != internal_default_instance() && hurter_ != NULL;
}
inline const ::NFMsg::Ident& BigMapGridBaseInfo::_internal_hurter() const {
  return *hurter_;
}
inline const ::NFMsg::Ident& BigMapGridBaseInfo::hurter() const {
  const ::NFMsg::Ident* p = hurter_;
  // @@protoc_insertion_point(field_get:NFMsg.BigMapGridBaseInfo.hurter)
  return p != NULL ? *p : *reinterpret_cast<const ::NFMsg::Ident*>(
      &::NFMsg::_Ident_default_instance_);
}
inline ::NFMsg::Ident* BigMapGridBaseInfo::release_hurter() {
  // @@protoc_insertion_point(field_release:NFMsg.BigMapGridBaseInfo.hurter)
  
  ::NFMsg::Ident* temp = hurter_;
  hurter_ = NULL;
  return temp;
}
inline ::NFMsg::Ident* BigMapGridBaseInfo::mutable_hurter() {
  
  if (hurter_ == NULL) {
    auto* p = CreateMaybeMessage<::NFMsg::Ident>(GetArenaNoVirtual());
    hurter_ = p;
  }
  // @@protoc_insertion_point(field_mutable:NFMsg.BigMapGridBaseInfo.hurter)
  return hurter_;
}
inline void BigMapGridBaseInfo::set_allocated_hurter(::NFMsg::Ident* hurter) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(hurter_);
  }
  if (hurter) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      hurter = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, hurter, submessage_arena);
    }
    
  } else {
    
  }
  hurter_ = hurter;
  // @@protoc_insertion_point(field_set_allocated:NFMsg.BigMapGridBaseInfo.hurter)
}

// -------------------------------------------------------------------

// BigMapLeaveMsg

// .NFMsg.Ident owner = 1;
inline bool BigMapLeaveMsg::has_owner() const {
  return this != internal_default_instance() && owner_ != NULL;
}
inline const ::NFMsg::Ident& BigMapLeaveMsg::_internal_owner() const {
  return *owner_;
}
inline const ::NFMsg::Ident& BigMapLeaveMsg::owner() const {
  const ::NFMsg::Ident* p = owner_;
  // @@protoc_insertion_point(field_get:NFMsg.BigMapLeaveMsg.owner)
  return p != NULL ? *p : *reinterpret_cast<const ::NFMsg::Ident*>(
      &::NFMsg::_Ident_default_instance_);
}
inline ::NFMsg::Ident* BigMapLeaveMsg::release_owner() {
  // @@protoc_insertion_point(field_release:NFMsg.BigMapLeaveMsg.owner)
  
  ::NFMsg::Ident* temp = owner_;
  owner_ = NULL;
  return temp;
}
inline ::NFMsg::Ident* BigMapLeaveMsg::mutable_owner() {
  
  if (owner_ == NULL) {
    auto* p = CreateMaybeMessage<::NFMsg::Ident>(GetArenaNoVirtual());
    owner_ = p;
  }
  // @@protoc_insertion_point(field_mutable:NFMsg.BigMapLeaveMsg.owner)
  return owner_;
}
inline void BigMapLeaveMsg::set_allocated_owner(::NFMsg::Ident* owner) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(owner_);
  }
  if (owner) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      owner = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, owner, submessage_arena);
    }
    
  } else {
    
  }
  owner_ = owner;
  // @@protoc_insertion_point(field_set_allocated:NFMsg.BigMapLeaveMsg.owner)
}

// bytes owner_name = 2;
inline void BigMapLeaveMsg::clear_owner_name() {
  owner_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& BigMapLeaveMsg::owner_name() const {
  // @@protoc_insertion_point(field_get:NFMsg.BigMapLeaveMsg.owner_name)
  return owner_name_.GetNoArena();
}
inline void BigMapLeaveMsg::set_owner_name(const ::std::string& value) {
  
  owner_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:NFMsg.BigMapLeaveMsg.owner_name)
}
#if LANG_CXX11
inline void BigMapLeaveMsg::set_owner_name(::std::string&& value) {
  
  owner_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:NFMsg.BigMapLeaveMsg.owner_name)
}
#endif
inline void BigMapLeaveMsg::set_owner_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  owner_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:NFMsg.BigMapLeaveMsg.owner_name)
}
inline void BigMapLeaveMsg::set_owner_name(const void* value, size_t size) {
  
  owner_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:NFMsg.BigMapLeaveMsg.owner_name)
}
inline ::std::string* BigMapLeaveMsg::mutable_owner_name() {
  
  // @@protoc_insertion_point(field_mutable:NFMsg.BigMapLeaveMsg.owner_name)
  return owner_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BigMapLeaveMsg::release_owner_name() {
  // @@protoc_insertion_point(field_release:NFMsg.BigMapLeaveMsg.owner_name)
  
  return owner_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BigMapLeaveMsg::set_allocated_owner_name(::std::string* owner_name) {
  if (owner_name != NULL) {
    
  } else {
    
  }
  owner_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), owner_name);
  // @@protoc_insertion_point(field_set_allocated:NFMsg.BigMapLeaveMsg.owner_name)
}

// bytes msg_data = 3;
inline void BigMapLeaveMsg::clear_msg_data() {
  msg_data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& BigMapLeaveMsg::msg_data() const {
  // @@protoc_insertion_point(field_get:NFMsg.BigMapLeaveMsg.msg_data)
  return msg_data_.GetNoArena();
}
inline void BigMapLeaveMsg::set_msg_data(const ::std::string& value) {
  
  msg_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:NFMsg.BigMapLeaveMsg.msg_data)
}
#if LANG_CXX11
inline void BigMapLeaveMsg::set_msg_data(::std::string&& value) {
  
  msg_data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:NFMsg.BigMapLeaveMsg.msg_data)
}
#endif
inline void BigMapLeaveMsg::set_msg_data(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  msg_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:NFMsg.BigMapLeaveMsg.msg_data)
}
inline void BigMapLeaveMsg::set_msg_data(const void* value, size_t size) {
  
  msg_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:NFMsg.BigMapLeaveMsg.msg_data)
}
inline ::std::string* BigMapLeaveMsg::mutable_msg_data() {
  
  // @@protoc_insertion_point(field_mutable:NFMsg.BigMapLeaveMsg.msg_data)
  return msg_data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BigMapLeaveMsg::release_msg_data() {
  // @@protoc_insertion_point(field_release:NFMsg.BigMapLeaveMsg.msg_data)
  
  return msg_data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BigMapLeaveMsg::set_allocated_msg_data(::std::string* msg_data) {
  if (msg_data != NULL) {
    
  } else {
    
  }
  msg_data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), msg_data);
  // @@protoc_insertion_point(field_set_allocated:NFMsg.BigMapLeaveMsg.msg_data)
}

// int32 msg_time = 4;
inline void BigMapLeaveMsg::clear_msg_time() {
  msg_time_ = 0;
}
inline ::google::protobuf::int32 BigMapLeaveMsg::msg_time() const {
  // @@protoc_insertion_point(field_get:NFMsg.BigMapLeaveMsg.msg_time)
  return msg_time_;
}
inline void BigMapLeaveMsg::set_msg_time(::google::protobuf::int32 value) {
  
  msg_time_ = value;
  // @@protoc_insertion_point(field_set:NFMsg.BigMapLeaveMsg.msg_time)
}

// int32 owner_level = 5;
inline void BigMapLeaveMsg::clear_owner_level() {
  owner_level_ = 0;
}
inline ::google::protobuf::int32 BigMapLeaveMsg::owner_level() const {
  // @@protoc_insertion_point(field_get:NFMsg.BigMapLeaveMsg.owner_level)
  return owner_level_;
}
inline void BigMapLeaveMsg::set_owner_level(::google::protobuf::int32 value) {
  
  owner_level_ = value;
  // @@protoc_insertion_point(field_set:NFMsg.BigMapLeaveMsg.owner_level)
}

// -------------------------------------------------------------------

// BigMapWarHistory

// .NFMsg.GridClanBaseInfo red_info = 1;
inline bool BigMapWarHistory::has_red_info() const {
  return this != internal_default_instance() && red_info_ != NULL;
}
inline void BigMapWarHistory::clear_red_info() {
  if (GetArenaNoVirtual() == NULL && red_info_ != NULL) {
    delete red_info_;
  }
  red_info_ = NULL;
}
inline const ::NFMsg::GridClanBaseInfo& BigMapWarHistory::_internal_red_info() const {
  return *red_info_;
}
inline const ::NFMsg::GridClanBaseInfo& BigMapWarHistory::red_info() const {
  const ::NFMsg::GridClanBaseInfo* p = red_info_;
  // @@protoc_insertion_point(field_get:NFMsg.BigMapWarHistory.red_info)
  return p != NULL ? *p : *reinterpret_cast<const ::NFMsg::GridClanBaseInfo*>(
      &::NFMsg::_GridClanBaseInfo_default_instance_);
}
inline ::NFMsg::GridClanBaseInfo* BigMapWarHistory::release_red_info() {
  // @@protoc_insertion_point(field_release:NFMsg.BigMapWarHistory.red_info)
  
  ::NFMsg::GridClanBaseInfo* temp = red_info_;
  red_info_ = NULL;
  return temp;
}
inline ::NFMsg::GridClanBaseInfo* BigMapWarHistory::mutable_red_info() {
  
  if (red_info_ == NULL) {
    auto* p = CreateMaybeMessage<::NFMsg::GridClanBaseInfo>(GetArenaNoVirtual());
    red_info_ = p;
  }
  // @@protoc_insertion_point(field_mutable:NFMsg.BigMapWarHistory.red_info)
  return red_info_;
}
inline void BigMapWarHistory::set_allocated_red_info(::NFMsg::GridClanBaseInfo* red_info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete red_info_;
  }
  if (red_info) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      red_info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, red_info, submessage_arena);
    }
    
  } else {
    
  }
  red_info_ = red_info;
  // @@protoc_insertion_point(field_set_allocated:NFMsg.BigMapWarHistory.red_info)
}

// .NFMsg.GridClanBaseInfo blue_info = 2;
inline bool BigMapWarHistory::has_blue_info() const {
  return this != internal_default_instance() && blue_info_ != NULL;
}
inline void BigMapWarHistory::clear_blue_info() {
  if (GetArenaNoVirtual() == NULL && blue_info_ != NULL) {
    delete blue_info_;
  }
  blue_info_ = NULL;
}
inline const ::NFMsg::GridClanBaseInfo& BigMapWarHistory::_internal_blue_info() const {
  return *blue_info_;
}
inline const ::NFMsg::GridClanBaseInfo& BigMapWarHistory::blue_info() const {
  const ::NFMsg::GridClanBaseInfo* p = blue_info_;
  // @@protoc_insertion_point(field_get:NFMsg.BigMapWarHistory.blue_info)
  return p != NULL ? *p : *reinterpret_cast<const ::NFMsg::GridClanBaseInfo*>(
      &::NFMsg::_GridClanBaseInfo_default_instance_);
}
inline ::NFMsg::GridClanBaseInfo* BigMapWarHistory::release_blue_info() {
  // @@protoc_insertion_point(field_release:NFMsg.BigMapWarHistory.blue_info)
  
  ::NFMsg::GridClanBaseInfo* temp = blue_info_;
  blue_info_ = NULL;
  return temp;
}
inline ::NFMsg::GridClanBaseInfo* BigMapWarHistory::mutable_blue_info() {
  
  if (blue_info_ == NULL) {
    auto* p = CreateMaybeMessage<::NFMsg::GridClanBaseInfo>(GetArenaNoVirtual());
    blue_info_ = p;
  }
  // @@protoc_insertion_point(field_mutable:NFMsg.BigMapWarHistory.blue_info)
  return blue_info_;
}
inline void BigMapWarHistory::set_allocated_blue_info(::NFMsg::GridClanBaseInfo* blue_info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete blue_info_;
  }
  if (blue_info) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      blue_info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, blue_info, submessage_arena);
    }
    
  } else {
    
  }
  blue_info_ = blue_info;
  // @@protoc_insertion_point(field_set_allocated:NFMsg.BigMapWarHistory.blue_info)
}

// .NFMsg.Ident winner_id = 10;
inline bool BigMapWarHistory::has_winner_id() const {
  return this != internal_default_instance() && winner_id_ != NULL;
}
inline const ::NFMsg::Ident& BigMapWarHistory::_internal_winner_id() const {
  return *winner_id_;
}
inline const ::NFMsg::Ident& BigMapWarHistory::winner_id() const {
  const ::NFMsg::Ident* p = winner_id_;
  // @@protoc_insertion_point(field_get:NFMsg.BigMapWarHistory.winner_id)
  return p != NULL ? *p : *reinterpret_cast<const ::NFMsg::Ident*>(
      &::NFMsg::_Ident_default_instance_);
}
inline ::NFMsg::Ident* BigMapWarHistory::release_winner_id() {
  // @@protoc_insertion_point(field_release:NFMsg.BigMapWarHistory.winner_id)
  
  ::NFMsg::Ident* temp = winner_id_;
  winner_id_ = NULL;
  return temp;
}
inline ::NFMsg::Ident* BigMapWarHistory::mutable_winner_id() {
  
  if (winner_id_ == NULL) {
    auto* p = CreateMaybeMessage<::NFMsg::Ident>(GetArenaNoVirtual());
    winner_id_ = p;
  }
  // @@protoc_insertion_point(field_mutable:NFMsg.BigMapWarHistory.winner_id)
  return winner_id_;
}
inline void BigMapWarHistory::set_allocated_winner_id(::NFMsg::Ident* winner_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(winner_id_);
  }
  if (winner_id) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      winner_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, winner_id, submessage_arena);
    }
    
  } else {
    
  }
  winner_id_ = winner_id;
  // @@protoc_insertion_point(field_set_allocated:NFMsg.BigMapWarHistory.winner_id)
}

// int32 war_time = 11;
inline void BigMapWarHistory::clear_war_time() {
  war_time_ = 0;
}
inline ::google::protobuf::int32 BigMapWarHistory::war_time() const {
  // @@protoc_insertion_point(field_get:NFMsg.BigMapWarHistory.war_time)
  return war_time_;
}
inline void BigMapWarHistory::set_war_time(::google::protobuf::int32 value) {
  
  war_time_ = value;
  // @@protoc_insertion_point(field_set:NFMsg.BigMapWarHistory.war_time)
}

// -------------------------------------------------------------------

// BigMapGridDetailInfo

// .NFMsg.BigMapGridBaseInfo grid_base_info = 1;
inline bool BigMapGridDetailInfo::has_grid_base_info() const {
  return this != internal_default_instance() && grid_base_info_ != NULL;
}
inline void BigMapGridDetailInfo::clear_grid_base_info() {
  if (GetArenaNoVirtual() == NULL && grid_base_info_ != NULL) {
    delete grid_base_info_;
  }
  grid_base_info_ = NULL;
}
inline const ::NFMsg::BigMapGridBaseInfo& BigMapGridDetailInfo::_internal_grid_base_info() const {
  return *grid_base_info_;
}
inline const ::NFMsg::BigMapGridBaseInfo& BigMapGridDetailInfo::grid_base_info() const {
  const ::NFMsg::BigMapGridBaseInfo* p = grid_base_info_;
  // @@protoc_insertion_point(field_get:NFMsg.BigMapGridDetailInfo.grid_base_info)
  return p != NULL ? *p : *reinterpret_cast<const ::NFMsg::BigMapGridBaseInfo*>(
      &::NFMsg::_BigMapGridBaseInfo_default_instance_);
}
inline ::NFMsg::BigMapGridBaseInfo* BigMapGridDetailInfo::release_grid_base_info() {
  // @@protoc_insertion_point(field_release:NFMsg.BigMapGridDetailInfo.grid_base_info)
  
  ::NFMsg::BigMapGridBaseInfo* temp = grid_base_info_;
  grid_base_info_ = NULL;
  return temp;
}
inline ::NFMsg::BigMapGridBaseInfo* BigMapGridDetailInfo::mutable_grid_base_info() {
  
  if (grid_base_info_ == NULL) {
    auto* p = CreateMaybeMessage<::NFMsg::BigMapGridBaseInfo>(GetArenaNoVirtual());
    grid_base_info_ = p;
  }
  // @@protoc_insertion_point(field_mutable:NFMsg.BigMapGridDetailInfo.grid_base_info)
  return grid_base_info_;
}
inline void BigMapGridDetailInfo::set_allocated_grid_base_info(::NFMsg::BigMapGridBaseInfo* grid_base_info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete grid_base_info_;
  }
  if (grid_base_info) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      grid_base_info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, grid_base_info, submessage_arena);
    }
    
  } else {
    
  }
  grid_base_info_ = grid_base_info;
  // @@protoc_insertion_point(field_set_allocated:NFMsg.BigMapGridDetailInfo.grid_base_info)
}

// repeated .NFMsg.GridClanBaseInfo stay_guid_list = 2;
inline int BigMapGridDetailInfo::stay_guid_list_size() const {
  return stay_guid_list_.size();
}
inline void BigMapGridDetailInfo::clear_stay_guid_list() {
  stay_guid_list_.Clear();
}
inline ::NFMsg::GridClanBaseInfo* BigMapGridDetailInfo::mutable_stay_guid_list(int index) {
  // @@protoc_insertion_point(field_mutable:NFMsg.BigMapGridDetailInfo.stay_guid_list)
  return stay_guid_list_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NFMsg::GridClanBaseInfo >*
BigMapGridDetailInfo::mutable_stay_guid_list() {
  // @@protoc_insertion_point(field_mutable_list:NFMsg.BigMapGridDetailInfo.stay_guid_list)
  return &stay_guid_list_;
}
inline const ::NFMsg::GridClanBaseInfo& BigMapGridDetailInfo::stay_guid_list(int index) const {
  // @@protoc_insertion_point(field_get:NFMsg.BigMapGridDetailInfo.stay_guid_list)
  return stay_guid_list_.Get(index);
}
inline ::NFMsg::GridClanBaseInfo* BigMapGridDetailInfo::add_stay_guid_list() {
  // @@protoc_insertion_point(field_add:NFMsg.BigMapGridDetailInfo.stay_guid_list)
  return stay_guid_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::NFMsg::GridClanBaseInfo >&
BigMapGridDetailInfo::stay_guid_list() const {
  // @@protoc_insertion_point(field_list:NFMsg.BigMapGridDetailInfo.stay_guid_list)
  return stay_guid_list_;
}

// repeated .NFMsg.BigMapLeaveMsg leave_msg = 3;
inline int BigMapGridDetailInfo::leave_msg_size() const {
  return leave_msg_.size();
}
inline void BigMapGridDetailInfo::clear_leave_msg() {
  leave_msg_.Clear();
}
inline ::NFMsg::BigMapLeaveMsg* BigMapGridDetailInfo::mutable_leave_msg(int index) {
  // @@protoc_insertion_point(field_mutable:NFMsg.BigMapGridDetailInfo.leave_msg)
  return leave_msg_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NFMsg::BigMapLeaveMsg >*
BigMapGridDetailInfo::mutable_leave_msg() {
  // @@protoc_insertion_point(field_mutable_list:NFMsg.BigMapGridDetailInfo.leave_msg)
  return &leave_msg_;
}
inline const ::NFMsg::BigMapLeaveMsg& BigMapGridDetailInfo::leave_msg(int index) const {
  // @@protoc_insertion_point(field_get:NFMsg.BigMapGridDetailInfo.leave_msg)
  return leave_msg_.Get(index);
}
inline ::NFMsg::BigMapLeaveMsg* BigMapGridDetailInfo::add_leave_msg() {
  // @@protoc_insertion_point(field_add:NFMsg.BigMapGridDetailInfo.leave_msg)
  return leave_msg_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::NFMsg::BigMapLeaveMsg >&
BigMapGridDetailInfo::leave_msg() const {
  // @@protoc_insertion_point(field_list:NFMsg.BigMapGridDetailInfo.leave_msg)
  return leave_msg_;
}

// repeated .NFMsg.BigMapWarHistory war_history = 4;
inline int BigMapGridDetailInfo::war_history_size() const {
  return war_history_.size();
}
inline void BigMapGridDetailInfo::clear_war_history() {
  war_history_.Clear();
}
inline ::NFMsg::BigMapWarHistory* BigMapGridDetailInfo::mutable_war_history(int index) {
  // @@protoc_insertion_point(field_mutable:NFMsg.BigMapGridDetailInfo.war_history)
  return war_history_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NFMsg::BigMapWarHistory >*
BigMapGridDetailInfo::mutable_war_history() {
  // @@protoc_insertion_point(field_mutable_list:NFMsg.BigMapGridDetailInfo.war_history)
  return &war_history_;
}
inline const ::NFMsg::BigMapWarHistory& BigMapGridDetailInfo::war_history(int index) const {
  // @@protoc_insertion_point(field_get:NFMsg.BigMapGridDetailInfo.war_history)
  return war_history_.Get(index);
}
inline ::NFMsg::BigMapWarHistory* BigMapGridDetailInfo::add_war_history() {
  // @@protoc_insertion_point(field_add:NFMsg.BigMapGridDetailInfo.war_history)
  return war_history_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::NFMsg::BigMapWarHistory >&
BigMapGridDetailInfo::war_history() const {
  // @@protoc_insertion_point(field_list:NFMsg.BigMapGridDetailInfo.war_history)
  return war_history_;
}

// -------------------------------------------------------------------

// AckBigMapGridInfo

// repeated .NFMsg.BigMapGridDetailInfo map_data = 1;
inline int AckBigMapGridInfo::map_data_size() const {
  return map_data_.size();
}
inline void AckBigMapGridInfo::clear_map_data() {
  map_data_.Clear();
}
inline ::NFMsg::BigMapGridDetailInfo* AckBigMapGridInfo::mutable_map_data(int index) {
  // @@protoc_insertion_point(field_mutable:NFMsg.AckBigMapGridInfo.map_data)
  return map_data_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NFMsg::BigMapGridDetailInfo >*
AckBigMapGridInfo::mutable_map_data() {
  // @@protoc_insertion_point(field_mutable_list:NFMsg.AckBigMapGridInfo.map_data)
  return &map_data_;
}
inline const ::NFMsg::BigMapGridDetailInfo& AckBigMapGridInfo::map_data(int index) const {
  // @@protoc_insertion_point(field_get:NFMsg.AckBigMapGridInfo.map_data)
  return map_data_.Get(index);
}
inline ::NFMsg::BigMapGridDetailInfo* AckBigMapGridInfo::add_map_data() {
  // @@protoc_insertion_point(field_add:NFMsg.AckBigMapGridInfo.map_data)
  return map_data_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::NFMsg::BigMapGridDetailInfo >&
AckBigMapGridInfo::map_data() const {
  // @@protoc_insertion_point(field_list:NFMsg.AckBigMapGridInfo.map_data)
  return map_data_;
}

// -------------------------------------------------------------------

// ReqBigMapInfo

// -------------------------------------------------------------------

// AckBigMapInfo

// repeated .NFMsg.BigMapGridBaseInfo grid_base_info = 1;
inline int AckBigMapInfo::grid_base_info_size() const {
  return grid_base_info_.size();
}
inline void AckBigMapInfo::clear_grid_base_info() {
  grid_base_info_.Clear();
}
inline ::NFMsg::BigMapGridBaseInfo* AckBigMapInfo::mutable_grid_base_info(int index) {
  // @@protoc_insertion_point(field_mutable:NFMsg.AckBigMapInfo.grid_base_info)
  return grid_base_info_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NFMsg::BigMapGridBaseInfo >*
AckBigMapInfo::mutable_grid_base_info() {
  // @@protoc_insertion_point(field_mutable_list:NFMsg.AckBigMapInfo.grid_base_info)
  return &grid_base_info_;
}
inline const ::NFMsg::BigMapGridBaseInfo& AckBigMapInfo::grid_base_info(int index) const {
  // @@protoc_insertion_point(field_get:NFMsg.AckBigMapInfo.grid_base_info)
  return grid_base_info_.Get(index);
}
inline ::NFMsg::BigMapGridBaseInfo* AckBigMapInfo::add_grid_base_info() {
  // @@protoc_insertion_point(field_add:NFMsg.AckBigMapInfo.grid_base_info)
  return grid_base_info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::NFMsg::BigMapGridBaseInfo >&
AckBigMapInfo::grid_base_info() const {
  // @@protoc_insertion_point(field_list:NFMsg.AckBigMapInfo.grid_base_info)
  return grid_base_info_;
}

// -------------------------------------------------------------------

// ReqHoldMapGrid

// bytes map_title_id = 1;
inline void ReqHoldMapGrid::clear_map_title_id() {
  map_title_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ReqHoldMapGrid::map_title_id() const {
  // @@protoc_insertion_point(field_get:NFMsg.ReqHoldMapGrid.map_title_id)
  return map_title_id_.GetNoArena();
}
inline void ReqHoldMapGrid::set_map_title_id(const ::std::string& value) {
  
  map_title_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:NFMsg.ReqHoldMapGrid.map_title_id)
}
#if LANG_CXX11
inline void ReqHoldMapGrid::set_map_title_id(::std::string&& value) {
  
  map_title_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:NFMsg.ReqHoldMapGrid.map_title_id)
}
#endif
inline void ReqHoldMapGrid::set_map_title_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  map_title_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:NFMsg.ReqHoldMapGrid.map_title_id)
}
inline void ReqHoldMapGrid::set_map_title_id(const void* value, size_t size) {
  
  map_title_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:NFMsg.ReqHoldMapGrid.map_title_id)
}
inline ::std::string* ReqHoldMapGrid::mutable_map_title_id() {
  
  // @@protoc_insertion_point(field_mutable:NFMsg.ReqHoldMapGrid.map_title_id)
  return map_title_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ReqHoldMapGrid::release_map_title_id() {
  // @@protoc_insertion_point(field_release:NFMsg.ReqHoldMapGrid.map_title_id)
  
  return map_title_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ReqHoldMapGrid::set_allocated_map_title_id(::std::string* map_title_id) {
  if (map_title_id != NULL) {
    
  } else {
    
  }
  map_title_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), map_title_id);
  // @@protoc_insertion_point(field_set_allocated:NFMsg.ReqHoldMapGrid.map_title_id)
}

// .NFMsg.Ident guild_id = 2;
inline bool ReqHoldMapGrid::has_guild_id() const {
  return this != internal_default_instance() && guild_id_ != NULL;
}
inline const ::NFMsg::Ident& ReqHoldMapGrid::_internal_guild_id() const {
  return *guild_id_;
}
inline const ::NFMsg::Ident& ReqHoldMapGrid::guild_id() const {
  const ::NFMsg::Ident* p = guild_id_;
  // @@protoc_insertion_point(field_get:NFMsg.ReqHoldMapGrid.guild_id)
  return p != NULL ? *p : *reinterpret_cast<const ::NFMsg::Ident*>(
      &::NFMsg::_Ident_default_instance_);
}
inline ::NFMsg::Ident* ReqHoldMapGrid::release_guild_id() {
  // @@protoc_insertion_point(field_release:NFMsg.ReqHoldMapGrid.guild_id)
  
  ::NFMsg::Ident* temp = guild_id_;
  guild_id_ = NULL;
  return temp;
}
inline ::NFMsg::Ident* ReqHoldMapGrid::mutable_guild_id() {
  
  if (guild_id_ == NULL) {
    auto* p = CreateMaybeMessage<::NFMsg::Ident>(GetArenaNoVirtual());
    guild_id_ = p;
  }
  // @@protoc_insertion_point(field_mutable:NFMsg.ReqHoldMapGrid.guild_id)
  return guild_id_;
}
inline void ReqHoldMapGrid::set_allocated_guild_id(::NFMsg::Ident* guild_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(guild_id_);
  }
  if (guild_id) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      guild_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, guild_id, submessage_arena);
    }
    
  } else {
    
  }
  guild_id_ = guild_id;
  // @@protoc_insertion_point(field_set_allocated:NFMsg.ReqHoldMapGrid.guild_id)
}

// -------------------------------------------------------------------

// AckHoldMapGrid

// -------------------------------------------------------------------

// ReqLeaveMapMsg

// bytes map_title_id = 1;
inline void ReqLeaveMapMsg::clear_map_title_id() {
  map_title_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ReqLeaveMapMsg::map_title_id() const {
  // @@protoc_insertion_point(field_get:NFMsg.ReqLeaveMapMsg.map_title_id)
  return map_title_id_.GetNoArena();
}
inline void ReqLeaveMapMsg::set_map_title_id(const ::std::string& value) {
  
  map_title_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:NFMsg.ReqLeaveMapMsg.map_title_id)
}
#if LANG_CXX11
inline void ReqLeaveMapMsg::set_map_title_id(::std::string&& value) {
  
  map_title_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:NFMsg.ReqLeaveMapMsg.map_title_id)
}
#endif
inline void ReqLeaveMapMsg::set_map_title_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  map_title_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:NFMsg.ReqLeaveMapMsg.map_title_id)
}
inline void ReqLeaveMapMsg::set_map_title_id(const void* value, size_t size) {
  
  map_title_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:NFMsg.ReqLeaveMapMsg.map_title_id)
}
inline ::std::string* ReqLeaveMapMsg::mutable_map_title_id() {
  
  // @@protoc_insertion_point(field_mutable:NFMsg.ReqLeaveMapMsg.map_title_id)
  return map_title_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ReqLeaveMapMsg::release_map_title_id() {
  // @@protoc_insertion_point(field_release:NFMsg.ReqLeaveMapMsg.map_title_id)
  
  return map_title_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ReqLeaveMapMsg::set_allocated_map_title_id(::std::string* map_title_id) {
  if (map_title_id != NULL) {
    
  } else {
    
  }
  map_title_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), map_title_id);
  // @@protoc_insertion_point(field_set_allocated:NFMsg.ReqLeaveMapMsg.map_title_id)
}

// .NFMsg.BigMapLeaveMsg leave_msg = 2;
inline bool ReqLeaveMapMsg::has_leave_msg() const {
  return this != internal_default_instance() && leave_msg_ != NULL;
}
inline void ReqLeaveMapMsg::clear_leave_msg() {
  if (GetArenaNoVirtual() == NULL && leave_msg_ != NULL) {
    delete leave_msg_;
  }
  leave_msg_ = NULL;
}
inline const ::NFMsg::BigMapLeaveMsg& ReqLeaveMapMsg::_internal_leave_msg() const {
  return *leave_msg_;
}
inline const ::NFMsg::BigMapLeaveMsg& ReqLeaveMapMsg::leave_msg() const {
  const ::NFMsg::BigMapLeaveMsg* p = leave_msg_;
  // @@protoc_insertion_point(field_get:NFMsg.ReqLeaveMapMsg.leave_msg)
  return p != NULL ? *p : *reinterpret_cast<const ::NFMsg::BigMapLeaveMsg*>(
      &::NFMsg::_BigMapLeaveMsg_default_instance_);
}
inline ::NFMsg::BigMapLeaveMsg* ReqLeaveMapMsg::release_leave_msg() {
  // @@protoc_insertion_point(field_release:NFMsg.ReqLeaveMapMsg.leave_msg)
  
  ::NFMsg::BigMapLeaveMsg* temp = leave_msg_;
  leave_msg_ = NULL;
  return temp;
}
inline ::NFMsg::BigMapLeaveMsg* ReqLeaveMapMsg::mutable_leave_msg() {
  
  if (leave_msg_ == NULL) {
    auto* p = CreateMaybeMessage<::NFMsg::BigMapLeaveMsg>(GetArenaNoVirtual());
    leave_msg_ = p;
  }
  // @@protoc_insertion_point(field_mutable:NFMsg.ReqLeaveMapMsg.leave_msg)
  return leave_msg_;
}
inline void ReqLeaveMapMsg::set_allocated_leave_msg(::NFMsg::BigMapLeaveMsg* leave_msg) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete leave_msg_;
  }
  if (leave_msg) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      leave_msg = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, leave_msg, submessage_arena);
    }
    
  } else {
    
  }
  leave_msg_ = leave_msg;
  // @@protoc_insertion_point(field_set_allocated:NFMsg.ReqLeaveMapMsg.leave_msg)
}

// -------------------------------------------------------------------

// AckLeaveMapMsg

// -------------------------------------------------------------------

// ReqGetMapAward

// bytes map_title_id = 1;
inline void ReqGetMapAward::clear_map_title_id() {
  map_title_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ReqGetMapAward::map_title_id() const {
  // @@protoc_insertion_point(field_get:NFMsg.ReqGetMapAward.map_title_id)
  return map_title_id_.GetNoArena();
}
inline void ReqGetMapAward::set_map_title_id(const ::std::string& value) {
  
  map_title_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:NFMsg.ReqGetMapAward.map_title_id)
}
#if LANG_CXX11
inline void ReqGetMapAward::set_map_title_id(::std::string&& value) {
  
  map_title_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:NFMsg.ReqGetMapAward.map_title_id)
}
#endif
inline void ReqGetMapAward::set_map_title_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  map_title_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:NFMsg.ReqGetMapAward.map_title_id)
}
inline void ReqGetMapAward::set_map_title_id(const void* value, size_t size) {
  
  map_title_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:NFMsg.ReqGetMapAward.map_title_id)
}
inline ::std::string* ReqGetMapAward::mutable_map_title_id() {
  
  // @@protoc_insertion_point(field_mutable:NFMsg.ReqGetMapAward.map_title_id)
  return map_title_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ReqGetMapAward::release_map_title_id() {
  // @@protoc_insertion_point(field_release:NFMsg.ReqGetMapAward.map_title_id)
  
  return map_title_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ReqGetMapAward::set_allocated_map_title_id(::std::string* map_title_id) {
  if (map_title_id != NULL) {
    
  } else {
    
  }
  map_title_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), map_title_id);
  // @@protoc_insertion_point(field_set_allocated:NFMsg.ReqGetMapAward.map_title_id)
}

// -------------------------------------------------------------------

// AckGetMapAward

// -------------------------------------------------------------------

// ReqMapHunting

// bytes map_title_id = 1;
inline void ReqMapHunting::clear_map_title_id() {
  map_title_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ReqMapHunting::map_title_id() const {
  // @@protoc_insertion_point(field_get:NFMsg.ReqMapHunting.map_title_id)
  return map_title_id_.GetNoArena();
}
inline void ReqMapHunting::set_map_title_id(const ::std::string& value) {
  
  map_title_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:NFMsg.ReqMapHunting.map_title_id)
}
#if LANG_CXX11
inline void ReqMapHunting::set_map_title_id(::std::string&& value) {
  
  map_title_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:NFMsg.ReqMapHunting.map_title_id)
}
#endif
inline void ReqMapHunting::set_map_title_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  map_title_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:NFMsg.ReqMapHunting.map_title_id)
}
inline void ReqMapHunting::set_map_title_id(const void* value, size_t size) {
  
  map_title_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:NFMsg.ReqMapHunting.map_title_id)
}
inline ::std::string* ReqMapHunting::mutable_map_title_id() {
  
  // @@protoc_insertion_point(field_mutable:NFMsg.ReqMapHunting.map_title_id)
  return map_title_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ReqMapHunting::release_map_title_id() {
  // @@protoc_insertion_point(field_release:NFMsg.ReqMapHunting.map_title_id)
  
  return map_title_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ReqMapHunting::set_allocated_map_title_id(::std::string* map_title_id) {
  if (map_title_id != NULL) {
    
  } else {
    
  }
  map_title_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), map_title_id);
  // @@protoc_insertion_point(field_set_allocated:NFMsg.ReqMapHunting.map_title_id)
}

// -------------------------------------------------------------------

// AckMapHunting

// -------------------------------------------------------------------

// ReqMapKingWar

// bytes map_title = 1;
inline void ReqMapKingWar::clear_map_title() {
  map_title_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ReqMapKingWar::map_title() const {
  // @@protoc_insertion_point(field_get:NFMsg.ReqMapKingWar.map_title)
  return map_title_.GetNoArena();
}
inline void ReqMapKingWar::set_map_title(const ::std::string& value) {
  
  map_title_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:NFMsg.ReqMapKingWar.map_title)
}
#if LANG_CXX11
inline void ReqMapKingWar::set_map_title(::std::string&& value) {
  
  map_title_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:NFMsg.ReqMapKingWar.map_title)
}
#endif
inline void ReqMapKingWar::set_map_title(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  map_title_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:NFMsg.ReqMapKingWar.map_title)
}
inline void ReqMapKingWar::set_map_title(const void* value, size_t size) {
  
  map_title_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:NFMsg.ReqMapKingWar.map_title)
}
inline ::std::string* ReqMapKingWar::mutable_map_title() {
  
  // @@protoc_insertion_point(field_mutable:NFMsg.ReqMapKingWar.map_title)
  return map_title_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ReqMapKingWar::release_map_title() {
  // @@protoc_insertion_point(field_release:NFMsg.ReqMapKingWar.map_title)
  
  return map_title_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ReqMapKingWar::set_allocated_map_title(::std::string* map_title) {
  if (map_title != NULL) {
    
  } else {
    
  }
  map_title_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), map_title);
  // @@protoc_insertion_point(field_set_allocated:NFMsg.ReqMapKingWar.map_title)
}

// -------------------------------------------------------------------

// AckMapKingWar

// bytes map_title = 1;
inline void AckMapKingWar::clear_map_title() {
  map_title_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AckMapKingWar::map_title() const {
  // @@protoc_insertion_point(field_get:NFMsg.AckMapKingWar.map_title)
  return map_title_.GetNoArena();
}
inline void AckMapKingWar::set_map_title(const ::std::string& value) {
  
  map_title_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:NFMsg.AckMapKingWar.map_title)
}
#if LANG_CXX11
inline void AckMapKingWar::set_map_title(::std::string&& value) {
  
  map_title_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:NFMsg.AckMapKingWar.map_title)
}
#endif
inline void AckMapKingWar::set_map_title(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  map_title_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:NFMsg.AckMapKingWar.map_title)
}
inline void AckMapKingWar::set_map_title(const void* value, size_t size) {
  
  map_title_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:NFMsg.AckMapKingWar.map_title)
}
inline ::std::string* AckMapKingWar::mutable_map_title() {
  
  // @@protoc_insertion_point(field_mutable:NFMsg.AckMapKingWar.map_title)
  return map_title_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AckMapKingWar::release_map_title() {
  // @@protoc_insertion_point(field_release:NFMsg.AckMapKingWar.map_title)
  
  return map_title_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AckMapKingWar::set_allocated_map_title(::std::string* map_title) {
  if (map_title != NULL) {
    
  } else {
    
  }
  map_title_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), map_title);
  // @@protoc_insertion_point(field_set_allocated:NFMsg.AckMapKingWar.map_title)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace NFMsg

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_NFMsgExtra_2eproto
